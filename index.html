<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>W.PRO+ Analytics v3.9 (Trade Plan)</title>

  <!-- Lightweight Charts -->
  <script src="https://cdn.jsdelivr.net/npm/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.js"></script>

  <style>
    :root {
      /* 專業深色主題 */
      --bg-color: #0b0e11;
      --panel-bg: #151a21;
      --border-color: #2a2e39;
      --text-main: #e0e3eb;
      --text-muted: #8d9096;
      --accent-color: #2962ff;
      
      /* 這些顏色會由 JS 動態決定，預設為美股 (綠漲紅跌) */
      --up-color: #089981;
      --down-color: #f23645;
      
      --warn-color: #fbc02d;
      
      --wma13-color: #00bcd4;
      --wma26-color: #9c27b0;
      --wma52-color: #e91e63;
      
      --rs-line: #ff9800;
      --rs-ma: #b2b5be;
      --rsi-line: #9c27b0; 
    }

    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

    body {
      margin: 0;
      background-color: var(--bg-color);
      color: var(--text-main);
      font-family: -apple-system, BlinkMacSystemFont, "Microsoft JhengHei", "Segoe UI", Roboto, sans-serif;
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    ::-webkit-scrollbar { width: 6px; height: 6px; }
    ::-webkit-scrollbar-track { background: var(--bg-color); }
    ::-webkit-scrollbar-thumb { background: #363a45; border-radius: 3px; }

    /* Header */
    header {
      height: 52px;
      background: var(--panel-bg);
      border-bottom: 1px solid var(--border-color);
      display: flex;
      align-items: center;
      padding: 0 16px;
      gap: 12px;
      flex-shrink: 0;
      z-index: 20;
      white-space: nowrap;
      overflow-x: auto;
    }

    .logo {
      font-weight: 900;
      font-size: 18px;
      color: #fff;
      margin-right: 4px;
    }
    .logo span { color: var(--accent-color); }

    .control-group {
      display: flex;
      align-items: center;
      gap: 6px;
      border-right: 1px solid var(--border-color);
      padding-right: 12px;
      height: 32px;
    }
    .control-group:last-child { border-right: none; }

    /* 強制顯示標籤 */
    .control-label {
      font-size: 11px;
      color: var(--text-muted);
      font-weight: 600;
      display: block; 
      margin-right: 4px;
    }

    input[type="text"], input[type="number"], select {
      background: #000000;
      border: 1px solid var(--border-color);
      color: #fff;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 13px;
      outline: none;
      transition: border-color 0.2s;
    }
    input[type="text"]:focus, input[type="number"]:focus, select:focus { border-color: var(--accent-color); }
    
    button.btn-primary {
      background: var(--accent-color);
      color: #fff;
      border: none;
      padding: 5px 14px;
      border-radius: 4px;
      font-weight: 600;
      font-size: 13px;
      cursor: pointer;
    }
    button.btn-icon {
      background: transparent;
      border: 1px solid var(--border-color);
      color: var(--text-muted);
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }
    button.btn-icon:hover { color: #fff; border-color: #fff; }
    button.btn-primary:hover { filter: brightness(1.1); }

    .segmented {
      display: flex;
      background: #000;
      border-radius: 4px;
      border: 1px solid var(--border-color);
      overflow: hidden;
    }
    .segmented button {
      background: transparent;
      border: none;
      color: var(--text-muted);
      padding: 4px 10px;
      font-size: 12px;
      cursor: pointer;
      border-right: 1px solid var(--border-color);
    }
    .segmented button:last-child { border-right: none; }
    .segmented button:hover { color: var(--text-main); background: #1e222d; }
    .segmented button.active { background: #2a2e39; color: #fff; font-weight: 600; }
    
    .segmented button.active[data-wma="13"] { color: var(--wma13-color); background: rgba(0, 188, 212, 0.15); }
    .segmented button.active[data-wma="26"] { color: var(--wma26-color); background: rgba(156, 39, 176, 0.15); }
    .segmented button.active[data-wma="52"] { color: var(--wma52-color); background: rgba(233, 30, 99, 0.15); }

    /* Layout */
    .layout { display: flex; flex: 1; overflow: hidden; }

    .sidebar {
      width: 200px;
      background: var(--panel-bg);
      border-right: 1px solid var(--border-color);
      display: flex;
      flex-direction: column;
      flex-shrink: 0;
    }
    .sidebar-header { padding: 12px; font-size: 12px; font-weight: 700; color: var(--text-muted); border-bottom: 1px solid var(--border-color); }
    .watch-list { overflow-y: auto; flex: 1; }
    .watch-item { padding: 10px 14px; border-bottom: 1px solid var(--border-color); cursor: pointer; transition: background 0.2s; }
    .watch-item:hover { background: #2a2e39; }
    .watch-item.active { background: #2a2e39; border-left: 3px solid var(--accent-color); }
    .w-symbol { font-weight: 600; font-size: 13px; color: #fff; }
    .w-name { font-size: 11px; color: var(--text-muted); margin-top: 2px; }

    .chart-container { flex: 1; display: flex; flex-direction: column; background: var(--bg-color); position: relative; }
    .chart-main { flex: 1; position: relative; width: 100%; }
    .chart-sub { height: 25%; min-height: 150px; border-top: 1px solid var(--border-color); position: relative; width: 100%; }
    #chart-main-div, #chart-sub-div { width: 100%; height: 100%; }

    /* Analysis Panel */
    .panel {
      width: 360px;
      background: var(--panel-bg);
      border-left: 1px solid var(--border-color);
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      flex-shrink: 0;
      padding: 16px;
      gap: 16px;
    }
    @media (max-width: 1000px) { .sidebar { display: none; } }
    @media (max-width: 800px) { .panel { display: none; } }

    .card {
      background: #1e232b;
      border: 1px solid var(--border-color);
      border-radius: 6px;
      padding: 12px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    .card-header {
      font-size: 14px;
      font-weight: 700;
      color: #fff;
      margin-bottom: 12px;
      border-bottom: 1px solid var(--border-color);
      padding-bottom: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    /* 確保移除所有小黃點 - 硬性規範 */
    .card-header span::before { content: none !important; }

    .gauge-wrap { display: flex; align-items: center; gap: 16px; margin-bottom: 12px; }
    .gauge {
      width: 100px; height: 50px;
      background: conic-gradient(from 180deg, #787b86 0deg, var(--down-color) 50deg, #fbc02d 100deg, var(--up-color) 150deg, #2962ff 180deg);
      border-radius: 100px 100px 0 0;
      position: relative;
    }
    .gauge-inner {
      width: 80px; height: 40px;
      background: #1e232b;
      border-radius: 80px 80px 0 0;
      position: absolute; bottom: 0; left: 10px;
    }
    .needle {
      width: 2px; height: 45px;
      background: #fff;
      position: absolute; bottom: 0; left: 50%;
      transform-origin: bottom center;
      transform: rotate(-90deg);
      transition: transform 0.8s ease-out;
    }
    .score-big { font-size: 32px; font-weight: 800; color: #fff; line-height: 1; text-align: center; }
    .score-text { font-size: 13px; color: var(--text-muted); margin-top: 4px; text-align: center; }

    .mini-metrics {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px 16px;
      font-size: 12px;
      border-top: 1px dashed var(--border-color);
      padding-top: 12px;
    }
    .mm-item { display: flex; justify-content: space-between; }
    .mm-label { color: var(--text-muted); }
    .mm-val { font-weight: bold; color: var(--text-main); }

    .m-item { 
      background: #0d1117; padding: 8px 10px; border-radius: 4px; 
      display: flex; justify-content: space-between; align-items: center; 
      font-size: 13px; border: 1px solid transparent;
      margin-bottom: 6px;
    }
    .m-label { color: var(--text-muted); }
    .m-val { font-weight: 700; color: var(--text-main); }

    .tag-pill {
      display: inline-block;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid var(--border-color);
      font-size: 12px;
      margin: 2px 4px 2px 0;
      color: var(--text-main);
    }

    .check-item {
      display: flex; justify-content: space-between; align-items: center;
      margin-bottom: 8px; font-size: 13px;
      border-bottom: 1px dashed #2a2e39; padding-bottom: 6px;
    }
    .check-item:last-child { border-bottom: none; }
    .check-label { color: var(--text-muted); }
    
    .badge {
      padding: 2px 8px; border-radius: 4px;
      font-size: 11px; font-weight: 700;
      min-width: 50px; text-align: center;
    }
    .badge-pass { background: rgba(8, 153, 129, 0.2); color: var(--up-color); border: 1px solid var(--up-color); }
    .badge-fail { background: rgba(242, 54, 69, 0.2); color: var(--down-color); border: 1px solid var(--down-color); }
    .badge-warn { background: rgba(251, 192, 45, 0.2); color: #fbc02d; border: 1px solid #fbc02d; }
    .badge-neutral { background: #363a45; color: #ccc; }
    
    .check-detail { font-size: 11px; color: #666; margin-top: 2px; text-align: right; }
    
    .stage-desc { 
      font-size: 13px; color: #e0e3eb; 
      margin-top: 10px; padding: 10px; 
      background: rgba(255,255,255,0.05); border-radius: 4px; 
      line-height: 1.6;
      border-left: 3px solid var(--accent-color);
    }
    .stage-desc strong { display: block; margin-bottom: 4px; color: #fff; }

    .risk-note {
      font-size: 11px; color: #6b7280; margin-top: 10px; line-height: 1.4;
      border-top: 1px solid var(--border-color); padding-top: 8px;
    }

    /* Fixed Tooltip Style */
    .tt-container {
      position: absolute; display: none;
      z-index: 100;
      background: #11131a;
      border: 1px solid #2a2e39;
      border-radius: 4px; 
      padding: 10px;
      pointer-events: none;
      box-shadow: 0 4px 12px rgba(0,0,0,0.5);
      min-width: 160px;
      font-family: 'Roboto Mono', monospace; 
      font-size: 12px;
      color: #e5e7eb;
    }
    .tt-header { 
      font-weight: 700; color: #fff; 
      margin-bottom: 8px; 
      font-size: 13px;
    }
    .tt-row { 
      display: flex; justify-content: space-between; align-items: center;
      margin-bottom: 4px; line-height: 1.4;
    }
    .tt-lbl { color: #8d9096; font-weight: normal; } 
    .tt-val { font-weight: 600; text-align: right; }
    
    .c-up { color: var(--up-color); } 
    .c-down { color: var(--down-color); }
    .c-vol { color: #fff; }
    .c-sma { color: #2962ff; }
    .c-rs { color: #ff9800; }
    .c-rsma { color: #b2b5be; }
    .c-rsi { color: #9c27b0; }
    
    .status-bar { margin-left: auto; font-size: 12px; color: var(--warn-color); font-weight: 600; }
    .loading-overlay {
      position: absolute; inset: 0; background: rgba(11,14,17,0.8);
      display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 50;
    }
    .spinner {
      width: 30px; height: 30px; border: 3px solid #363a45;
      border-top-color: var(--accent-color); border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

  
  /* UI Variant C */
  body {
    background: radial-gradient(circle at top, #111827 0, #020617 55%);
  }
  .card {
    background: #020617;
    border-radius: 14px;
    border: 1px solid rgba(75,85,99,0.6);
    box-shadow: 0 10px 30px rgba(0,0,0,0.7);
  }
  
  #stageBadge.badge-pass {
    background: linear-gradient(135deg, #22c55e, #4ade80);
    color: #022c22;
  }
  #stageBadge.badge-warn {
    background: linear-gradient(135deg, #facc15, #f97316);
    color: #451a03;
  }
  #stageBadge.badge-fail {
    background: linear-gradient(135deg, #f97373, #ef4444);
    color: #7f1d1d;
  }
  .m-item {
    border-radius: 999px;
    padding-inline: 14px;
  }
  .tag-pill {
    border-radius: 999px;
    background: rgba(15,23,42,0.92);
    border-color: rgba(250,204,21,0.6);
  }

  .check-item-row {
    margin-bottom: 10px;
  }
  .check-main-line {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 8px;
  }
  .status-pill {
    padding: 2px 10px;
    border-radius: 999px;
    font-size: 11px;
    font-weight: 600;
    border: 1px solid transparent;
  }
  .status-pass {
    background: rgba(34,197,94,0.12);
    border-color: rgba(34,197,94,0.7);
    color: #4ade80;
  }
  .status-warn {
    background: rgba(234,179,8,0.12);
    border-color: rgba(234,179,8,0.8);
    color: #facc15;
  }
  .status-fail {
    background: rgba(248,113,113,0.12);
    border-color: rgba(248,113,113,0.85);
    color: #f97373;
  }
  .check-desc {
    margin-top: 2px;
    font-size: 12px;
    color: #a0aec0;
  }

  /* === Tone badges for cards === */
  .tone-pill {
    padding: 2px 10px;
    border-radius: 999px;
    font-size: 11px;
    font-weight: 700;
    border: 1px solid transparent;
    margin-left: auto;
    display: flex;
    align-items: center;
    gap: 4px;
  }
  /* 徹底移除所有黃色菱形點 - 硬性規範 */
  .tone-pill::before { content: none !important; }
  
  .tone-bull {
    background: rgba(34,197,94,0.1);
    border-color: #22c55e;
    color: #4ade80;
    box-shadow: 0 0 5px rgba(34,197,94,0.2);
  }
  .tone-bear {
    background: rgba(239,68,68,0.1);
    border-color: #ef4444;
    color: #f87171;
    box-shadow: 0 0 5px rgba(239,68,68,0.2);
  }
  .tone-neutral {
    background: rgba(148,163,184,0.1);
    border-color: #94a3b8;
    color: #cbd5e1;
  }

  .tone-val-bull { color: var(--up-color); font-weight: 600; }
  .tone-val-bear { color: var(--down-color); font-weight: 600; }
  .tone-val-neutral { color: #9ca3af; }

  /* Input group specific */
  .risk-inputs {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
    margin-bottom: 8px;
  }
  .risk-input-group { display: flex; flex-direction: column; gap: 4px; }
  .risk-input-group label { font-size: 11px; color: var(--text-muted); }
  .risk-input-group input { width: 100%; text-align: right; }
  
  .pos-size-result {
    background: rgba(41, 98, 255, 0.1);
    border: 1px solid var(--accent-color);
    padding: 8px;
    border-radius: 4px;
    text-align: center;
    margin-top: 8px;
  }
  .pos-size-val { font-size: 16px; font-weight: 800; color: #fff; }
  .pos-size-lbl { font-size: 11px; color: var(--accent-color); }

  /* New CSS for JCH Cards */
  .jch-list { margin-top: 10px; }
  .jch-item { display: flex; align-items: center; justify-content: space-between; margin-bottom: 6px; font-size: 13px; }
  .jch-item:last-child { margin-bottom: 0; }
  
  .dragon-reason-list {
    margin-top: 8px; list-style: none; padding: 0; font-size: 12px; color: #a0aec0;
  }
  .dragon-reason-list li { margin-bottom: 4px; position: relative; padding-left: 14px; }
  .dragon-reason-list li::before { 
    content: "•"; color: var(--accent-color); position: absolute; left: 0; font-weight: bold; 
  }
  .entry-zone-val { font-size: 18px; font-weight: 700; color: #fff; margin: 4px 0; }
  
  /* START: Fix Pills (需求 C: 修正 PASS/FAIL/WARN 膠囊大小一致) */
  .status-pill, .tone-pill, .badge {
    min-width: 60px;          /* 統一最小寬度 */
    height: 22px;             /* 統一高度 */
    line-height: 20px;        /* 扣除 border 的行高，確保文字垂直置中 */
    display: inline-flex;     /* 改為 inline-flex 方便置中 */
    align-items: center;      /* 垂直置中 */
    justify-content: center;  /* 水平置中 */
    white-space: nowrap;      /* 文字不換行 */
    box-sizing: border-box;
  }
  /* 微調間距 */
  .jch-item .status-pill {
    padding: 0 8px;
  }
  /* END: Fix Pills */

  /* START: WEIN Styles */
  #weinParams {
    margin-top: 10px;
    padding-top: 10px;
    border-top: 1px dashed var(--border-color);
    display: none; /* Collapsible */
  }
  .wein-row {
    display: flex;
    gap: 8px;
    margin-bottom: 6px;
    font-size: 12px;
    align-items: center;
  }
  .wein-row label {
    color: var(--text-muted);
    flex: 1;
  }
  .wein-row input {
    width: 60px;
    text-align: right;
    padding: 2px 4px;
  }
  .wein-toggle-btn {
    font-size: 11px;
    color: var(--accent-color);
    cursor: pointer;
    text-align: center;
    margin-top: 8px;
    text-decoration: underline;
  }
  /* END: WEIN Styles */

  /* START: V06_TUNING */
  /* Hint Style - 低調說明文字 */
  #weinParams .hint {
    font-size: 11px;
    opacity: 0.7;
    font-weight: normal;
    color: #8d9096;
    /* Modified for Goal B & Task 3 */
    display: block;
    margin-left: 0;
    margin-top: 3px;
    line-height: 1.25;
  }
  
  #weinFeedback {
    margin-top: 10px;
    padding: 8px;
    background: rgba(255,255,255,0.05);
    border-radius: 4px;
    font-size: 12px;
    color: #ccc;
    line-height: 1.5;
    border-left: 3px solid var(--accent-color);
    display: none;
  }
  #weinFeedback strong { color:#fff; }

  /* Reorder support for Task C */
  .panel { display: flex; flex-direction: column; }
  /* END: V06_TUNING */

</style>
</head>
<body>

<header>
  <div class="logo">W.PRO<span>+</span></div>
  
  <div class="control-group">
    <input type="text" id="symbolInput" value="2330.TW" placeholder="代號" style="width: 80px;">
    <button class="btn-primary" id="searchBtn">分析</button>
  </div>

  <div class="control-group">
    <span class="control-label">週期</span>
    <div class="segmented" id="tfButtons">
      <button data-tf="15m">15m</button>
      <button data-tf="30m">30m</button>
      <button data-tf="60m">60m</button>
      <button data-tf="1d">日</button>
      <button data-tf="1wk" class="active">週</button>
    </div>
  </div>

  <div class="control-group">
    <span class="control-label">RS基準</span>
    <select id="rsBenchmark" style="width: 80px;">
      <optgroup label="台灣">
        <option value="^TWII" selected>加權</option>
        <option value="^TWO">櫃買</option>
      </optgroup>
      <optgroup label="美國">
        <option value="^GSPC">S&P500</option>
        <option value="^DJI">道瓊</option>
        <option value="^IXIC">Nasdaq</option>
        <option value="^SOX">費半</option>
      </optgroup>
    </select>
  </div>

  <!-- 恢復 WMA 輔助控制項 -->
  <div class="control-group">
    <span class="control-label">WMA輔助</span>
    <div class="segmented" id="wmaAuxButtons">
      <button data-wma="13">13</button>
      <button data-wma="26">26</button>
      <button data-wma="52">52</button>
    </div>
  </div>

  <div class="control-group">
    <span class="control-label">主均線</span>
    <div class="segmented" id="maTypeButtons">
      <button data-type="SMA" class="active">SMA</button>
      <button data-type="WMA">WMA</button>
    </div>
    <div class="segmented" id="maLenButtons" style="margin-left: 2px;">
      <button data-len="20">20</button>
      <button data-len="30" class="active">30</button>
      <button data-len="60">60</button>
    </div>
  </div>

  <div class="control-group">
    <span class="control-label">副圖</span>
    <div class="segmented" id="subChartType">
      <button data-type="RS" class="active">RS</button>
      <button data-type="RSI">RSI</button>
    </div>
  </div>

  <div class="control-group">
    <span class="control-label">工具</span>
    <button class="btn-icon" id="dlCsvBtn" title="下載 CSV">⭳</button>
    <!-- START: WEIN CSV Upload Button -->
    <button class="btn-icon" id="weinCsvBtn" title="匯入 CSV (Weinstein)">CSV</button>
    <input type="file" id="weinCsvInput" accept=".csv" style="display:none">
    <!-- END: WEIN -->
  </div>

  <div class="control-group" style="border:none;">
    <div class="segmented" id="langButtons">
      <button data-lang="zh" class="active">中</button>
      <button data-lang="en">EN</button>
    </div>
  </div>

  <div id="statusBar" class="status-bar"></div>
</header>

<div class="layout">
  <aside class="sidebar">
    <div class="sidebar-header">自選觀察 (Watchlist)</div>
    <div class="watch-list" id="watchList"></div>
  </aside>

  <main class="chart-container">
    <div id="loading" class="loading-overlay">
      <div class="spinner"></div>
      <div style="margin-top:10px; font-size:12px; color:#ccc;">資料讀取中...</div>
    </div>
    
    <div id="tooltip" class="tt-container"></div>

    <div class="chart-main"><div id="chart-main-div"></div></div>
    <div class="chart-sub"><div id="chart-sub-div"></div></div>
  </main>

  <aside class="panel">
    <div class="card">
      <div class="card-header">多空戰力 (Momentum)</div>
      <div class="gauge-wrap">
        <div class="gauge">
          <div class="needle" id="gaugeNeedle"></div>
          <div class="gauge-inner"></div>
        </div>
        <div style="flex:1; text-align:center;">
          <div id="scoreVal" class="score-big">--</div>
          <div id="scoreText" class="score-text">等待分析</div>
        </div>
      </div>
      <div class="mini-metrics">
        <div class="mm-item"><span class="mm-label">趨勢 Trend</span><span id="scoreTrend" class="mm-val">-</span></div>
        <div class="mm-item"><span class="mm-label">動能 Mom.</span><span id="scoreMom" class="mm-val">-</span></div>
        <div class="mm-item"><span class="mm-label">量能 Vol.</span><span id="scoreVol" class="mm-val">-</span></div>
        <div class="mm-item"><span class="mm-label">RS 強度</span><span id="scoreRS" class="mm-val">-</span></div>
      </div>
    </div>

    <!-- START: TRADE_PLAN_CARD_V1 -->
    <div class="card" id="tradePlanCard" style="order: 2;">
      <div class="card-header">
        <span>交易計畫 (Trade Plan)</span>
        <span id="tp_grade_pill" class="status-pill status-neutral">N/A</span>
      </div>
      
      <!-- START: TRADE_PLAN_CARD_V2 -->
      
      <!-- 欄位 (6) 安全部位 Position Sizing -->
      <div class="risk-inputs" style="margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px dashed var(--border-color);">
        <div class="risk-input-group">
          <label for="tpInputCapital">資金 (Capital)</label>
          <input type="number" id="tpInputCapital" value="100000" step="10000" style="height: 28px; font-size: 12px; padding: 2px 6px;">
        </div>
        <div class="risk-input-group">
          <label for="tpInputRiskPct">風險 % (Risk %)</label>
          <input type="number" id="tpInputRiskPct" value="1" step="0.5" style="height: 28px; font-size: 12px; padding: 2px 6px;">
        </div>
      </div>
      
      <div id="tp_content_summary">
        <div style="text-align:center; color:#555; font-size:12px;">請輸入代號開始分析並設定資金</div>
      </div>
      
      <div id="tp_grade_details" class="stage-desc" style="margin-top: 12px; border-left-color: #fbc02d; display: none;">
        <!-- JS will populate Setup Grade and Reasons -->
      </div>
      
      <div id="tp_do_dont" style="margin-top: 12px; padding-top: 8px; border-top: 1px dashed var(--border-color);">
        <!-- JS will populate Do / Don't list here -->
      </div>

      <div class="risk-note" style="margin-top: 8px; border-top: 1px solid var(--border-color); padding-top: 8px; text-align: right;">
        <span id="tp_disclaimer" style="font-size: 10px; color: #555;"></span>
      </div>
      
      <!-- END: TRADE_PLAN_CARD_V2 -->
    </div>
    <!-- END: TRADE_PLAN_CARD_V1 -->

    <div class="card">
      <div class="card-header">
        <span>目前階段 (Stage Analysis)</span>
        <span id="stageBadge" class="badge badge-neutral">N/A</span>
      </div>
      <div class="check-item">
        <span class="check-label">收盤價</span>
        <span id="infoPrice" style="font-weight:bold; color:#fff;">-</span>
      </div>
      <div class="check-item">
        <span class="check-label" id="infoMALabel">MA</span>
        <span id="infoMA" style="font-weight:bold; color:var(--accent-color);">-</span>
      </div>
      <div class="check-item">
        <span class="check-label">乖離率 (Bias)</span>
        <span id="infoBias" style="font-weight:bold;">-</span>
      </div>
      <div id="stageDesc" class="stage-desc">
        分析說明將顯示於此。
      </div>
      
      <!-- START: V06_TUNING Feedback Block -->
      <div id="weinFeedback"></div>
      <!-- END: V06_TUNING -->

      <!-- START: WEIN Params UI -->
      <div class="wein-toggle-btn" onclick="document.getElementById('weinParams').style.display = document.getElementById('weinParams').style.display==='block'?'none':'block'">
        進階參數 (Advanced Params)
      </div>
      <div id="weinParams">
        <!-- START: ADV_PARAMS_BILINGUAL_LABELS -->
        <div class="wein-row">
          <label>均線週期 (SMA Period)</label>
          <input type="number" id="weinMA" value="30">
        </div>
        <div class="wein-row">
          <label>斜率回看週期 (Slope Lookback)</label>
          <input type="number" id="weinSlopeLB" value="3">
        </div>
        <div class="wein-row">
          <label>多頭判定門檻 (Stage 2 Threshold)<span class="hint">價格高於均線的比例</span></label>
          <input type="number" id="weinThresh2" value="1.03" step="0.01">
        </div>
        <div class="wein-row">
          <label>空頭判定門檻 (Stage 4 Threshold)<span class="hint">價格低於均線的比例</span></label>
          <input type="number" id="weinThresh4" value="0.97" step="0.01">
        </div>
        <div class="wein-row">
          <label>斜率門檻 (Slope Threshold)<span class="hint">均線走平/走向的敏感度</span></label>
          <input type="number" id="weinSlopeThresh" value="0.005" step="0.001">
        </div>
        <!-- END: ADV_PARAMS_BILINGUAL_LABELS -->
        <div style="text-align:right; margin-top:8px;">
          <button class="btn-primary" style="padding: 4px 10px; font-size:11px;" id="weinApplyBtn">Apply</button>
        </div>
      </div>
      <!-- END: WEIN -->
    </div>

    <!-- NEW MODULE 1: JCH Strength -->
    <!-- START: V06_TUNING Task D: Rename Header -->
    <div class="card" id="jchCard">
      <div class="card-header" title="基於公開技術分析概念彙整，非任何個人/機構之官方內容">
        <span>JCH 模組 (Strength)</span>
        <span id="jch_tone" class="tone-pill tone-neutral">Neutral</span>
      </div>
    <!-- END: V06_TUNING -->
      <div style="display:flex; align-items:baseline; justify-content:center; padding:10px 0; border-bottom:1px dashed var(--border-color);">
        <span style="font-size:12px; color:var(--text-muted); margin-right:8px;">Score</span>
        <span id="jch_score" style="font-size:24px; font-weight:800; color:#fff;">--</span>
        <span style="font-size:12px; color:var(--text-muted);">/100</span>
      </div>
      <div class="jch-list" id="jch_list">
        <!-- JS will populate -->
      </div>
      <!-- START: 需求 B 擴充 JCH Trade Plan 說明區塊 -->
      <div id="jch_desc" class="stage-desc" style="display:none; border-left-color: #fbc02d;">
      </div>
      <!-- END: 需求 B -->
    </div>

    <!-- NEW MODULE 2: Dragon Stage -->
    <!-- START: V06_TUNING Task D: Rename Header -->
    <div class="card" id="dragonCard">
      <div class="card-header" title="基於公開技術分析概念彙整，非任何個人/機構之官方內容">
        <span>Dragon 模組 (Stage)</span>
      </div>
    <!-- END: V06_TUNING -->
      <div style="text-align:center; padding:10px 0;">
        <span id="cs_stage" class="tag-pill" style="font-size:14px; padding:4px 12px; font-weight:700;">--</span>
      </div>
      <ul class="dragon-reason-list" id="cs_reason">
        <!-- JS will populate -->
      </ul>
      <div id="cs_advice" class="risk-note" style="color:#fff;">
        <!-- JS will populate -->
      </div>
      <!-- START: 需求 A 擴充 CS 12 Setups 區塊 -->
      <div id="cs12_setup_block" class="stage-desc" style="display:none; border-left-color: #9c27b0;">
        <!-- JS renders CS12 Setups here -->
      </div>
      <!-- END: 需求 A -->
    </div>

    <!-- NEW MODULE 3: Entry Zone -->
    <div class="card" id="entryCard">
      <div class="card-header">
        <span>出手價建議 (Entry Zone)</span>
        <span id="entry_type" class="tone-pill tone-neutral">--</span>
      </div>
      <div style="text-align:center; padding:8px 0;">
        <div style="font-size:11px; color:var(--text-muted);">建議區間 / Target Zone</div>
        <div id="entry_zone" class="entry-zone-val">--</div>
      </div>
      <div id="entry_risk" class="risk-note" style="margin-top:4px;">
        <!-- JS will populate -->
      </div>
    </div>

    <!-- START: INTEGRATED_ADVICE_CARD -->
    <div class="card" id="integratedCard">
      <div class="card-header">
        <span>整合建議 (Integrated Advice)</span>
        <span id="integratedTone" class="tone-pill tone-neutral">Neutral</span>
      </div>
      <div style="padding: 0 4px;">
        <div id="integratedSummary" style="font-size: 15px; font-weight: 700; color: #fff; margin-bottom: 8px; padding-bottom:8px; border-bottom:1px dashed var(--border-color);">
          --
        </div>
        <ul id="integratedReasons" class="dragon-reason-list" style="margin-bottom: 12px;">
          <!-- JS Populates -->
        </ul>
        <div id="integratedRisk" class="risk-note" style="border-top:1px dashed var(--border-color); padding-top:8px;">
          --
        </div>
      </div>
    </div>
    <!-- END: INTEGRATED_ADVICE_CARD -->

    <div class="card">
      <div class="card-header">溫斯坦檢查表 (Checklist)</div>
      <div id="checklistItems">
        <div style="text-align:center; color:#555; font-size:12px;">請輸入代號開始分析</div>
      </div>
    </div>

    <div class="card">
      <div class="card-header">風險控管 (Risk Management)</div>
      <div class="risk-inputs">
        <div class="risk-input-group">
          <label>總資金 (Capital)</label>
          <input type="number" id="inputCapital" value="100000" step="10000">
        </div>
        <div class="risk-input-group">
          <label>風險 % (Risk)</label>
          <input type="number" id="inputRiskPct" value="2" step="0.5">
        </div>
      </div>

      <div class="check-item">
        <span class="check-label">建議停損 (Stop Loss)</span>
        <span id="riskInitial" style="color:var(--down-color); font-weight:bold;">-</span>
      </div>
      <div class="check-item">
        <span class="check-label">ATR 波動 (14)</span>
        <span id="valATR" style="color:#fff;">-</span>
      </div>
      
      <div class="pos-size-result">
        <div class="pos-size-val" id="calcShares">0</div>
        <div class="pos-size-lbl">建議股數 (Shares)</div>
      </div>

      <div class="risk-note">
        公式：(總資金 × 風險%) ÷ (現價 - 停損)。此為根據均線停損的部位建議。
      </div>
    </div>

    <!-- 5. 趨勢與市場位置總覽 (Trend & Market Analysis) -->
    <div class="card">
      <div class="card-header">
        <span>趨勢與市場位置 (Trend &amp; Market)</span>
        <span id="trendToneTag" class="tone-pill tone-neutral">中性</span>
      </div>
      
      <!-- Profile Section 已完全移除 -->

      <div id="analysisList">
        <div class="m-item"><span class="m-label">均線排列</span><span class="m-val" id="maAlignVal">-</span></div>
        <div class="m-item"><span class="m-label">位置狀態</span><span class="m-val">-</span></div>
        <div class="m-item"><span class="m-label">乖離率</span><span class="m-val">-</span></div>
        <div class="m-item"><span class="m-label">前高距離</span><span class="m-val">-</span></div>
        <div class="m-item"><span class="m-label">前低距離</span><span class="m-val">-</span></div>
        <div class="m-item"><span class="m-label">量能</span><span class="m-val">-</span></div>
        <div class="m-item"><span class="m-label">RS / RSI</span><span class="m-val">-</span></div>
      </div>
    </div>

    <!-- 6. PATTERN AI (簡易型態偵測) -->
    <div class="card">
      <div class="card-header">
        <span>PATTERN AI</span>
        <span id="patternToneTag" class="tone-pill tone-neutral">中性</span>
      </div>
      <div id="patternTags" style="display:flex; flex-wrap:wrap; min-height:30px;">
        <span style="font-size:12px; color:#555;">尚未偵測到明顯型態</span>
      </div>
    </div>

    <!-- 7. 支撐 / 壓力區 (S/R Levels) -->
    <div class="card">
      <div class="card-header">
        <span>S/R LEVELS</span>
        <span id="srToneTag" class="tone-pill tone-neutral">中性</span>
      </div>
      <div class="m-item" style="margin-bottom:6px;">
        <span class="m-label">極值壓力 (High/Low Extremes)</span>
        <span class="m-val" id="lvlResExt">-</span>
      </div>
      <div class="m-item" style="margin-bottom:6px;">
        <span class="m-label">極值支撐 (High/Low Extremes)</span>
        <span class="m-val" id="lvlSupExt">-</span>
      </div>
      <div class="m-item" style="margin-bottom:6px;">
        <span class="m-label">VAH (Volume Profile)</span>
        <span class="m-val" id="lvlVAH">-</span>
      </div>
      <div class="m-item" style="margin-bottom:6px;">
        <span class="m-label">VAL (Volume Profile)</span>
        <span class="m-val" id="lvlVAL">-</span>
      </div>
      <div class="m-item">
        <span class="m-label">POC (Volume Profile)</span>
        <span class="m-val" id="lvlPOC">-</span>
      </div>
    </div>

  </aside>
</div>

<script>
const PROXY_LIST = [
  { url: "https://corsproxy.io/?", type: "direct" },
  { url: "https://api.allorigins.win/raw?url=", type: "param" },
  { url: "https://thingproxy.freeboard.io/fetch/", type: "direct" }
];

const WATCHLIST_DATA = [
  { s: "2330.TW", n: "台積電" },
  { s: "2454.TW", n: "聯發科" },
  { s: "2603.TW", n: "長榮" },
  { s: "NVDA", n: "NVIDIA" },
  { s: "TSLA", n: "Tesla" },
  { s: "AAPL", n: "Apple" },
  { s: "AMD", n: "AMD" },
  { s: "^TWII", n: "加權指數" },
  { s: "^GSPC", n: "S&P 500" }
];

const COLORS = {
  US: { up: '#089981', down: '#f23645' }, // 美股：綠漲 紅跌
  TW: { up: '#f23645', down: '#089981' }  // 台股：紅漲 綠跌
};

let currentStateColors = { ...COLORS.US }; // 預設美股

let state = {
  symbol: "2330.TW",
  interval: "1wk",    
  maType: "SMA",      
  maLen: 30,
  rsBenchmark: "^TWII",
  subChart: 'RS', // 'RS' or 'RSI'
  wmaAux: { 13: false, 26: false, 52: false },
  lang: "zh",
  // START: TRADE_PLAN_CARD_V2 STATE
  riskCapital: 100000,
  riskPct: 1, // Default to 1% as requested
  // END: TRADE_PLAN_CARD_V2
  dataCache: { 
    stock: [], benchmark: [], ma: [], rs: [], rsMa: [], rsi: [], wmaAux: {},
    profile: { sector: '-' } 
  },
  // START: WEIN State
  weinMode: false,
  weinStage: 1, // Store computed stage
  // END: WEIN
};

function formatPrice(value, symbol) {
  if (value == null || isNaN(value)) return "-";
  const v = Number(value);
  const isTW = symbol && (symbol.endsWith(".TW") || symbol.endsWith(".TWO"));
  if (isTW) {
    return v.toFixed(2);
  }
  if (Math.abs(v) >= 100) return v.toFixed(2);
  if (Math.abs(v) >= 10) return v.toFixed(2);
  if (Math.abs(v) >= 1) return v.toFixed(3);
  return v.toFixed(4);
}

let charts = { main: null, sub: null, series: { candle: null, volume: null, mainMA: null, wmaAux: {}, rsLine: null, rsMA: null, rsiLine: null } };
let tooltipMap = { stock: new Map(), ma: new Map(), wmaAux: { 13: new Map(), 26: new Map(), 52: new Map() }, rs: new Map(), rsMa: new Map(), rsi: new Map() };

document.addEventListener('DOMContentLoaded', () => {
  // START: TRADE_PLAN_CARD_V2 INIT CALL
  TP_initUI();
  // END: TRADE_PLAN_CARD_V2
  initUI();
  initCharts();
  
  // START: V06_TUNING Task C: Reorder Cards
  reorderCards();
  // END: V06_TUNING
  
  runAnalysis();
});

// START: V06_TUNING Task C
function reorderCards() {
  const panel = document.querySelector('.panel');
  if (!panel) return;
  const cards = Array.from(panel.querySelectorAll('.card'));
  
  // Define order map based on Task C
  // 1) Momentum, 2) Trade Plan, 3) Integrated, 4) Stage, 5) Entry, 6) Checklist, 7) Risk, 8) JCH, 9) Dragon, 10) Setups
  
  cards.forEach(card => {
    const text = card.innerText || "";
    // Identify card type
    let order = 99;
    
    if (text.includes("多空戰力") || text.includes("Momentum")) order = 1;
    else if (card.id === 'tradePlanCard') order = 2; // New Card (Trade Plan)
    else if (card.id === 'integratedCard' || text.includes("整合建議")) order = 3;
    else if (text.includes("目前階段") || text.includes("Stage Analysis")) order = 4;
    else if (card.id === 'entryCard' || text.includes("出手價建議")) order = 5;
    else if (text.includes("檢查表") || text.includes("Checklist")) order = 6;
    else if (card.id === 'riskCard' || text.includes("風險控管")) order = 7; // Assuming Risk Management card ID is riskCard or checking text. It's the 7th card in HTML flow.
    else if (card.id === 'jchCard' || text.includes("JCH")) order = 8;
    else if (card.id === 'dragonCard' || text.includes("Dragon")) order = 9;
    
    card.style.order = order;
  });
}
// END: V06_TUNING

function isTaiwanStock(symbol) {
  return symbol.endsWith('.TW') || symbol.endsWith('.TWO') || symbol.startsWith('^TW');
}

function applyColorTheme(symbol) {
  const isTW = isTaiwanStock(symbol);
  currentStateColors = isTW ? COLORS.TW : COLORS.US;

  document.documentElement.style.setProperty('--up-color', currentStateColors.up);
  document.documentElement.style.setProperty('--down-color', currentStateColors.down);

  if (charts.series.candle) {
    charts.series.candle.applyOptions({
      upColor: currentStateColors.up,
      downColor: currentStateColors.down,
      wickUpColor: currentStateColors.up,
      wickDownColor: currentStateColors.down
    });
  }
}

function initUI() {
  const wlContainer = document.getElementById('watchList');
  WATCHLIST_DATA.forEach(item => {
    const el = document.createElement('div');
    el.className = 'watch-item';
    el.innerHTML = `<div class="w-symbol">${item.s}</div><div class="w-name">${item.n}</div>`;
    el.onclick = () => {
      document.querySelectorAll('.watch-item').forEach(d => d.classList.remove('active'));
      el.classList.add('active');
      document.getElementById('symbolInput').value = item.s;
      runAnalysis();
    };
    wlContainer.appendChild(el);
  });

  document.querySelectorAll('#tfButtons button').forEach(btn => {
    btn.onclick = () => { setActive(btn, '#tfButtons button'); state.interval = btn.dataset.tf; runAnalysis(); };
  });
  document.querySelectorAll('#maTypeButtons button').forEach(btn => {
    btn.onclick = () => { setActive(btn, '#maTypeButtons button'); state.maType = btn.dataset.type; recalcIndicators(); };
  });
  document.querySelectorAll('#maLenButtons button').forEach(btn => {
    btn.onclick = () => { setActive(btn, '#maLenButtons button'); state.maLen = parseInt(btn.dataset.len); recalcIndicators(); };
  });
  document.querySelectorAll('#wmaAuxButtons button').forEach(btn => {
    btn.onclick = () => {
      const v = parseInt(btn.dataset.wma);
      const active = btn.classList.toggle('active');
      state.wmaAux[v] = active;
      if(charts.series.wmaAux[v]) charts.series.wmaAux[v].applyOptions({ visible: active });
    };
  });
  document.querySelectorAll('#subChartType button').forEach(btn => {
    btn.onclick = () => { 
      setActive(btn, '#subChartType button'); 
      state.subChart = btn.dataset.type; 
      recalcIndicators(); 
    };
  });
  
  // Risk inputs (EXISTING RISK CARD INPUTS)
  document.getElementById('inputCapital').onchange = (e) => { state.riskCapital = parseFloat(e.target.value) || 100000; updatePositionSize(); };
  document.getElementById('inputRiskPct').onchange = (e) => { state.riskPct = parseFloat(e.target.value) || 2; updatePositionSize(); };

  // CSV Download
  document.getElementById('dlCsvBtn').onclick = downloadCSV;

  const langButtons = document.querySelectorAll('#langButtons button');
  langButtons.forEach(btn => {
    btn.onclick = () => {
      setActive(btn, '#langButtons button');
      state.lang = btn.dataset.lang || 'zh';
      if (state.dataCache.stock.length && state.dataCache.ma.length) {
        updateAnalysisPanel(state.dataCache.stock, state.dataCache.ma, state.dataCache.rsInfo);
      }
    };
  });

  document.getElementById('rsBenchmark').onchange = (e) => { state.rsBenchmark = e.target.value; runAnalysis(); };
  document.getElementById('searchBtn').onclick = runAnalysis;
  document.getElementById('symbolInput').onkeydown = (e) => { if(e.key === 'Enter') runAnalysis(); };

  // START: WEIN Event Listeners
  document.getElementById('weinCsvBtn').onclick = () => document.getElementById('weinCsvInput').click();
  document.getElementById('weinCsvInput').onchange = (e) => WEIN_handleFileUpload(e.target);
  document.getElementById('weinApplyBtn').onclick = () => WEIN_recalcFromWeekly();
  // END: WEIN
}

function setActive(target, selector) {
  document.querySelectorAll(selector).forEach(b => b.classList.remove('active'));
  target.classList.add('active');
}

function initCharts() {
  const chartOpts = {
    layout: { background: { type: 'solid', color: '#0b0e11' }, textColor: '#8d9096' },
    grid: { vertLines: { color: '#1e222d' }, horzLines: { color: '#1e222d' } },
    crosshair: { mode: 1, vertLine: { labelBackgroundColor: '#2962ff' } },
    timeScale: { borderColor: '#2a2e39', timeVisible: true, rightOffset: 5 },
    rightPriceScale: { borderColor: '#2a2e39' },
  };
  charts.main = LightweightCharts.createChart(document.getElementById('chart-main-div'), chartOpts);
  charts.sub = LightweightCharts.createChart(document.getElementById('chart-sub-div'), chartOpts);

  charts.series.candle = charts.main.addCandlestickSeries({ 
    upColor: currentStateColors.up, 
    downColor: currentStateColors.down, 
    borderVisible: false, 
    wickUpColor: currentStateColors.up, 
    wickDownColor: currentStateColors.down 
  });
  
  charts.series.volume = charts.main.addHistogramSeries({ priceFormat: { type: 'volume' }, priceScaleId: '' });
  charts.series.volume.priceScale().applyOptions({ scaleMargins: { top: 0.8, bottom: 0 } });
  charts.series.mainMA = charts.main.addLineSeries({ color: '#2962ff', lineWidth: 2 });
  
  charts.series.rsLine = charts.sub.addLineSeries({ color: '#ff9800', lineWidth: 2 });
  charts.series.rsMA = charts.sub.addLineSeries({ color: '#b2b5be', lineWidth: 1, lineStyle: 2 });
  // RSI Line - default invisible, same chart
  charts.series.rsiLine = charts.sub.addLineSeries({ color: '#9c27b0', lineWidth: 2, visible: false });
  
  // WMA Aux lines
  [13,26,52].forEach(p => {
    let c = p===13?'#00bcd4':(p===26?'#9c27b0':'#e91e63');
    charts.series.wmaAux[p] = charts.main.addLineSeries({ color: c, lineWidth: 1, visible: false });
  });

  const mainTimeScale = charts.main.timeScale();
  const subTimeScale = charts.sub.timeScale();
  let isSyncing = false;
  
  const syncLogical = (source, target) => {
    const range = source.getVisibleLogicalRange();
    if(!range) return;
    if(isSyncing) return;
    isSyncing = true;
    target.setVisibleLogicalRange(range);
    isSyncing = false;
  };

  mainTimeScale.subscribeVisibleLogicalRangeChange(() => syncLogical(mainTimeScale, subTimeScale));
  subTimeScale.subscribeVisibleLogicalRangeChange(() => syncLogical(subTimeScale, mainTimeScale));
  
  new ResizeObserver(e => { if(e[0]) charts.main.applyOptions({ width: e[0].contentRect.width, height: e[0].contentRect.height }); }).observe(document.getElementById('chart-main-div'));
  new ResizeObserver(e => { if(e[0]) charts.sub.applyOptions({ width: e[0].contentRect.width, height: e[0].contentRect.height }); }).observe(document.getElementById('chart-sub-div'));
  
  // START: V06_TUNING Task B: Crosshair Sync
  let isCrosshairSyncing = false;

  charts.main.subscribeCrosshairMove(param => {
    if (isCrosshairSyncing) return;
    isCrosshairSyncing = true;
    
    updateTooltip(param);
    
    if (param.time) {
      // Sync sub chart crosshair by value
      // Check current sub chart type
      let val = null;
      let series = null;
      if (state.subChart === 'RS') {
        val = tooltipMap.rs.get(param.time);
        series = charts.series.rsLine;
      } else {
        val = tooltipMap.rsi.get(param.time);
        series = charts.series.rsiLine;
      }
      
      if (val !== null && val !== undefined) {
        charts.sub.setCrosshairPosition(val, param.time, series);
      } else {
        charts.sub.clearCrosshairPosition();
      }
    } else {
      charts.sub.clearCrosshairPosition();
    }
    isCrosshairSyncing = false;
  });

  charts.sub.subscribeCrosshairMove(param => {
    if (isCrosshairSyncing) return;
    isCrosshairSyncing = true;
    
    updateTooltip(param); // Optional: show tooltip on sub hover too? Usually fine.
    
    if (param.time) {
      // Sync main chart crosshair by Close value
      const stock = tooltipMap.stock.get(param.time);
      if (stock) {
        charts.main.setCrosshairPosition(stock.close, param.time, charts.series.candle);
      } else {
        charts.main.clearCrosshairPosition();
      }
    } else {
      charts.main.clearCrosshairPosition();
    }
    isCrosshairSyncing = false;
  });
  // END: V06_TUNING
}

async function runAnalysis() {
  const symbol = document.getElementById('symbolInput').value.trim().toUpperCase();
  state.symbol = symbol;
  
  // START: WEIN Reset
  state.weinMode = false;
  // END: WEIN

  applyColorTheme(symbol);
  setLoading(true); setStatus("");

  try {
    let range = '5y'; 
    if (state.interval === '15m' || state.interval === '30m') range = '59d';
    if (state.interval === '60m') range = '730d';

    const [stockData, benchData] = await Promise.all([
      fetchYahoo(symbol, state.interval, range),
      fetchYahoo(state.rsBenchmark, state.interval, range)
    ]);

    if(!stockData || !stockData.length) throw new Error("無資料");

    state.dataCache.stock = stockData;
    state.dataCache.benchmark = benchData || [];
    state.dataCache.profile = { sector: '-' };
    
    tooltipMap.stock.clear();
    stockData.forEach(d => tooltipMap.stock.set(d.time, d));

    recalcIndicators();
  } catch(e) {
    console.error(e);
    setStatus("讀取失敗: " + e.message, true);
  } finally {
    setLoading(false);
  }
}

function recalcIndicators() {
  const { stock, benchmark } = state.dataCache;
  if(!stock.length) return;

  const mainMA = calcMA(stock, state.maLen, state.maType);
  state.dataCache.ma = mainMA;
  tooltipMap.ma.clear(); mainMA.forEach(d => tooltipMap.ma.set(d.time, d.value));
  charts.series.mainMA.setData(mainMA);
  
  // WMA Aux Calc
  [13, 26, 52].forEach(p => {
    const w = calcWMA(stock, p);
    state.dataCache.wmaAux[p] = w;
    tooltipMap.wmaAux[p].clear(); w.forEach(d => tooltipMap.wmaAux[p].set(d.time, d.value));
    charts.series.wmaAux[p].setData(w);
  });

  // RS Calculation
  const rsInfo = calcRSEnhanced(stock, benchmark);
  state.dataCache.rsInfo = rsInfo;
  
  // RSI Calculation
  const rsiData = calcRSI(stock, 14);
  state.dataCache.rsi = rsiData;
  tooltipMap.rsi.clear(); rsiData.forEach(d => tooltipMap.rsi.set(d.time, d.value));

  // Switch SubChart
  if (state.subChart === 'RS') {
    charts.series.rsLine.applyOptions({ visible: true });
    charts.series.rsMA.applyOptions({ visible: true });
    charts.series.rsiLine.applyOptions({ visible: false });
    
    charts.series.rsLine.setData(rsInfo.rsSeries);
    charts.series.rsMA.setData(rsInfo.rsMaSeries);
    charts.sub.priceScale().applyOptions({ autoScale: true, scaleMargins: {top:0.1, bottom:0.1} });

  } else {
    // RSI Mode
    charts.series.rsLine.applyOptions({ visible: false });
    charts.series.rsMA.applyOptions({ visible: false });
    charts.series.rsiLine.applyOptions({ visible: true });
    
    charts.series.rsiLine.setData(rsiData);
    charts.sub.priceScale().applyOptions({ autoScale: false, scaleMargins: {top:0.05, bottom:0.05} });
  }

  tooltipMap.rs.clear(); rsInfo.rsSeries.forEach(d => tooltipMap.rs.set(d.time, d.value));
  tooltipMap.rsMa.clear(); rsInfo.rsMaSeries.forEach(d => tooltipMap.rsMa.set(d.time, d.value));

  charts.series.candle.setData(stock);
  
  const hexToRgba = (hex, alpha) => {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
  };

  const upRgba = hexToRgba(currentStateColors.up, 0.3);
  const downRgba = hexToRgba(currentStateColors.down, 0.3);

  charts.series.volume.setData(stock.map(d => ({ 
    time: d.time, 
    value: d.volume, 
    color: d.close >= d.open ? upRgba : downRgba 
  })));
  
  const totalBars = stock.length;
  const visibleRange = 120;
  if(totalBars > visibleRange) {
    charts.main.timeScale().setVisibleLogicalRange({ from: totalBars - visibleRange, to: totalBars });
  } else {
    charts.main.timeScale().fitContent();
  }

  updateAnalysisPanel(stock, mainMA, rsInfo);
}

function updateTooltip(param) {
  const tt = document.getElementById('tooltip');
  if (!param.time || param.point.x < 0 || param.point.y < 0) { tt.style.display = 'none'; return; }
  const time = param.time;
  const stock = tooltipMap.stock.get(time);
  const ma = tooltipMap.ma.get(time);
  
  if (!stock) { tt.style.display = 'none'; return; }
  
  tt.style.display = 'block';
  const d = new Date(time * 1000);
  let dateStr = d.toISOString().split('T')[0];
  if(state.interval.includes('m')) dateStr += ` ${d.getHours().toString().padStart(2,'0')}:${d.getMinutes().toString().padStart(2,'0')}`;
  
  let html = `<div class="tt-header">${dateStr}</div>`;
  
  if (stock) {
    const valColor = stock.close >= stock.open ? 'c-up' : 'c-down';
    html += `
      <div class="tt-row"><span class="tt-lbl">開盤</span><span class="tt-val ${valColor}">${stock.open.toFixed(2)}</span></div>
      <div class="tt-row"><span class="tt-lbl">最高</span><span class="tt-val ${valColor}">${stock.high.toFixed(2)}</span></div>
      <div class="tt-row"><span class="tt-lbl">最低</span><span class="tt-val ${valColor}">${stock.low.toFixed(2)}</span></div>
      <div class="tt-row"><span class="tt-lbl">收盤</span><span class="tt-val ${valColor}">${stock.close.toFixed(2)}</span></div>
    `;
    let v = stock.volume >= 1e6 ? (stock.volume/1e6).toFixed(2)+'M' : (stock.volume/1e3).toFixed(0)+'K';
    html += `<div class="tt-row"><span class="tt-lbl">成交量</span><span class="tt-val c-vol">${v}</span></div>`;
  }
  
  if (ma) {
    html += `<div class="tt-row"><span class="tt-lbl">${state.maType}${state.maLen}</span><span class="tt-val c-sma">${ma.toFixed(2)}</span></div>`;
  }
  
  // WMA Aux Tooltip
  [13,26,52].forEach(p => {
    if(state.wmaAux[p]) {
      const v = tooltipMap.wmaAux[p].get(time);
      if(v) {
        let c = p===13?'#00bcd4':(p===26?'#9c27b0':'#e91e63');
        html += `<div class="tt-row"><span class="tt-lbl">WMA${p}</span><span class="tt-val" style="color:${c}">${v.toFixed(2)}</span></div>`;
      }
    }
  });

  if (state.subChart === 'RS') {
    const rs = tooltipMap.rs.get(time);
    const rsMa = tooltipMap.rsMa.get(time);
    // 分隔線
    html += `<div style="border-top:1px dashed #4b5563; margin:6px 0 4px 0;"></div>`;
    if (rs) {
      html += `<div class="tt-row"><span class="tt-lbl">RS 線</span><span class="tt-val c-rs">${rs.toFixed(4)}</span></div>`;
    }
    if (rsMa) {
      html += `<div class="tt-row"><span class="tt-lbl">RS MA20</span><span class="tt-val c-rsma">${rsMa.toFixed(4)}</span></div>`;
    }
  } else {
    const rsi = tooltipMap.rsi.get(time);
    html += `<div style="border-top:1px dashed #4b5563; margin:6px 0 4px 0;"></div>`;
    if (rsi) {
      html += `<div class="tt-row"><span class="tt-lbl">RSI(14)</span><span class="tt-val c-rsi">${rsi.toFixed(2)}</span></div>`;
    }
  }

  tt.innerHTML = html;
  
  const box = tt.getBoundingClientRect();
  const cBox = document.querySelector('.chart-container').getBoundingClientRect();
  let left = param.point.x + 15;
  let top = param.point.y + 15;
  if (left + box.width > cBox.width) left = param.point.x - box.width - 15;
  if (top + box.height > cBox.height) top = param.point.y - box.height - 15; 
  
  tt.style.left = left + 'px';
  tt.style.top = Math.max(10, top) + 'px';
}

function calcMA(data, len, type) {
  if(type === 'WMA') return calcWMA(data, len);
  const res = [];
  for(let i=0; i<data.length; i++) {
    if(i < len - 1) continue;
    let sum = 0;
    for(let j=0; j<len; j++) sum += data[i-j].close;
    res.push({ time: data[i].time, value: sum / len });
  }
  return res;
}
function calcWMA(data, len) {
  const res = [];
  let totalWeight = (len * (len + 1)) / 2;
  for (let i = 0; i < data.length; i++) {
    if (i < len - 1) continue;
    let sum = 0;
    for (let j = 0; j < len; j++) sum += data[i - j].close * (len - j);
    res.push({ time: data[i].time, value: sum / totalWeight });
  }
  return res;
}
function calcSMA(data, len) {
  const res = [];
  for(let i=0; i<data.length; i++) {
    if(i < len - 1) continue;
    let sum = 0;
    for(let j=0; j<len; j++) sum += data[i-j].close;
    res.push({ time: data[i].time, value: sum / len });
  }
  return res;
}

function calcRSEnhanced(stock, benchmark) {
  const bMap = new Map();
  benchmark.forEach(b => bMap.set(b.time, b.close));

  const rsRaw = [];
  let lastBench = null;

  for(let i=0; i<stock.length; i++) {
    const s = stock[i];
    let bClose = bMap.get(s.time);

    if(bClose !== undefined) {
      lastBench = bClose;
    } else if (lastBench !== null) {
      bClose = lastBench;
    }

    if(bClose && bClose > 0) {
      rsRaw.push({ time: s.time, value: s.close / bClose });
    } else {
      rsRaw.push({ time: s.time, value: NaN });
    }
  }

  const validRS = rsRaw.filter(r => !Number.isNaN(r.value));
  const rsMa20Raw = calcSMA(validRS.map(r => ({ time: r.time, close: r.value })), 20);
  const rsMa52Raw = calcSMA(validRS.map(r => ({ time: r.time, close: r.value })), 52);
  
  const ma20Map = new Map(); rsMa20Raw.forEach(m => ma20Map.set(m.time, m.value));
  const ma52Map = new Map(); rsMa52Raw.forEach(m => ma52Map.set(m.time, m.value));

  const rsMa20Aligned = [];
  stock.forEach(s => {
    const val = ma20Map.get(s.time);
    rsMa20Aligned.push({ time: s.time, value: val !== undefined ? val : NaN });
  });

  let mansfield = 0;
  if(validRS.length > 0) {
    const lastRS = validRS[validRS.length-1];
    const last52MA = ma52Map.get(lastRS.time);
    if(last52MA) mansfield = ((lastRS.value / last52MA) - 1) * 10;
  }
  
  const startVal = validRS[0]?.value || 1;
  const rsSeries = rsRaw.map(r => ({ time: r.time, value: r.value / startVal }));
  const rsMaSeries = rsMa20Aligned.map(r => ({ time: r.time, value: r.value / startVal }));

  return { rsSeries, rsMaSeries, mansfield };
}

function calcRSI(data, period=14) {
  const res = [];
  let avgGain = 0, avgLoss = 0;
  
  for(let i = 0; i < data.length; i++) {
     if(i < 1) continue;
     const chg = data[i].close - data[i-1].close;
     const gain = chg > 0 ? chg : 0;
     const loss = chg < 0 ? -chg : 0;

     if(i < period + 1) {
       avgGain += gain;
       avgLoss += loss;
       if(i === period) {
         avgGain /= period;
         avgLoss /= period;
         const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
         const rsi = avgLoss === 0 ? 100 : 100 - (100 / (1 + rs));
         rsiArray.push({ time: data[i].time, value: rsi });
       }
     } else {
       avgGain = ((avgGain * (period - 1)) + gain) / period;
       avgLoss = ((avgLoss * (period - 1)) + loss) / period;
       const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
       const rsi = avgLoss === 0 ? 100 : 100 - (100 / (1 + rs));
       rsiArray.push({ time: data[i].time, value: rsi });
     }
     
     // Helper for first loop init of rsiArray
     var rsiArray = rsiArray || [];
  }
  return rsiArray;
}

function calcATR(data, period=14) {
  const trs = [];
  for(let i=1; i<data.length; i++) {
    const high = data[i].high;
    const low = data[i].low;
    const prevClose = data[i-1].close;
    const tr = Math.max(high - low, Math.abs(high - prevClose), Math.abs(low - prevClose));
    trs.push(tr);
  }
  let sum = 0;
  const atrs = [];
  if(trs.length >= period) {
    for(let i=0; i<period; i++) sum += trs[i];
    atrs.push(sum/period);
    for(let i=period; i<trs.length; i++) {
      const prevATR = atrs[atrs.length-1];
      const currentATR = ((prevATR * (period-1)) + trs[i]) / period;
      atrs.push(currentATR);
    }
  }
  return atrs.length > 0 ? atrs[atrs.length-1] : 0;
}

function calcScoreDetails(r) {
  let trend=0, momentum=0, volume=0, rs=0;
  if (r.stage === 2) trend += 25; else if (r.stage === 4) trend -= 20; if (r.priceAboveMA) trend += 10;
  if (r.maUp) momentum += 20; else momentum -= 5;
  if (r.isVol) volume += 15;
  if (r.rsStrong) rs += 25; else if (r.benchmarkAvailable) rs -= 15;
  return { total: Math.max(0, Math.min(100, 40+trend+momentum+volume+rs)), trend, momentum, volume, rs };
}

function updateAnalysisPanel(stock, maData, rsInfo) {
  if (!stock || !stock.length || !maData || !maData.length) return;

  const last = stock[stock.length - 1];
  const maMap = new Map(maData.map(m => [m.time, m.value]));
  const curMA = maMap.get(last.time);
  const prevMA = maMap.get(stock[Math.max(0, stock.length - 4)].time);

  const maUp = (curMA && prevMA) ? curMA > prevMA : false;
  const priceAboveMA = curMA ? last.close > curMA : false;

  // MA Alignment Logic (20, 60, 200)
  const ma20Arr = calcSMA(stock, 20);
  const ma60Arr = calcSMA(stock, 60);
  const ma200Arr = calcSMA(stock, 200);
  
  const getVal = (arr) => arr.length ? arr[arr.length-1].value : 0;
  const v20 = getVal(ma20Arr);
  const v60 = getVal(ma60Arr);
  const v200 = getVal(ma200Arr);
  const price = last.close;

  let maAlignStatus = 'Mixed';
  let maAlignLabelZh = '整理糾結';
  let maAlignLabelEn = 'Mixed / Chop';
  let maAlignColor = '#888';

  if (v20 > v60 && v60 > v200 && price > v20) {
    maAlignStatus = 'Bull';
    maAlignLabelZh = '多頭排列 (強)';
    maAlignLabelEn = 'Bullish Align (Strong)';
    maAlignColor = 'var(--up-color)';
  } else if (v20 > v60 && v60 > v200 && price < v20) {
    maAlignStatus = 'BullCorrection';
    maAlignLabelZh = '多頭回檔';
    maAlignLabelEn = 'Bull Pullback';
    maAlignColor = 'var(--warn-color)';
  } else if (v20 < v60 && v60 < v200 && price < v20) {
    maAlignStatus = 'Bear';
    maAlignLabelZh = '空頭排列 (弱)';
    maAlignLabelEn = 'Bearish Align (Weak)';
    maAlignColor = 'var(--down-color)';
  } else if (v20 < v60 && v60 < v200 && price > v20) {
    maAlignStatus = 'BearRebound';
    maAlignLabelZh = '空頭反彈';
    maAlignLabelEn = 'Bear Rebound';
    maAlignColor = 'var(--warn-color)';
  }

  // Update Profile UI (Removed)

  let volSum = 0, volCnt = 0;
  for (let i = 1; i <= 20; i++) {
    const bar = stock[stock.length - 1 - i];
    if (bar) { volSum += bar.volume; volCnt++; }
  }
  const avgVol = volCnt ? volSum / volCnt : 1;
  const isVol = (last.volume > avgVol * 1.5) && (last.close > last.open);

  let maxHigh = 0;
  const lookback = Math.min(stock.length, 52);
  for (let i = 0; i < lookback; i++) {
    const bar = stock[stock.length - 1 - i];
    if (!bar) continue;
    if (bar.high > maxHigh) maxHigh = bar.high;
  }
  const isBlueSky = last.close >= maxHigh * 0.98;

  let stage = 1;
  if (priceAboveMA && maUp) stage = 2;
  else if (!priceAboveMA && !maUp) stage = 4;
  else if (!priceAboveMA && maUp) stage = 3;

  // START: WEIN Override
  if (state.weinMode && state.weinStage) {
    stage = state.weinStage;
  }
  // END: WEIN

  const scoreObj = calcScoreDetails({
    stage,
    priceAboveMA,
    maUp,
    isVol,
    rsStrong: rsInfo && typeof rsInfo.mansfield === 'number' ? rsInfo.mansfield > 0 : false,
    benchmarkAvailable: (state.dataCache.benchmark || []).length > 0
  });

  const scoreValEl = document.getElementById('scoreVal');
  const gaugeNeedle = document.getElementById('gaugeNeedle');
  const scoreTextEl = document.getElementById('scoreText');

  if (scoreValEl) scoreValEl.innerText = scoreObj.total;
  if (gaugeNeedle) gaugeNeedle.style.transform = `rotate(${(scoreObj.total / 100 * 180) - 90}deg)`;

  const lang = state.lang || 'zh';
  let txt;
  if (lang === 'zh') {
    txt = "中性整理";
    if (scoreObj.total >= 75) txt = "強勢多頭";
    else if (scoreObj.total >= 50) txt = "多方嘗試";
    else if (scoreObj.total <= 30) txt = "空方弱勢";
  } else {
    txt = "Neutral consolidation";
    if (scoreObj.total >= 75) txt = "Strong uptrend";
    else if (scoreObj.total >= 50) txt = "Bullish attempt";
    else if (scoreObj.total <= 30) txt = "Weak / bearish";
  }
  if (scoreTextEl) scoreTextEl.innerText = txt;

  const setMetric = (id, val, goodCond) => {
    const el = document.getElementById(id);
    if (!el) return;
    el.innerText = (val >= 0 ? "+" : "") + val;
    if (goodCond) el.style.color = "var(--up-color)";
    else if (val < 0) el.style.color = "var(--down-color)";
    else el.style.color = "#888";
  };

  setMetric('scoreTrend', scoreObj.trend, scoreObj.trend > 0);
  setMetric('scoreMom', scoreObj.momentum, scoreObj.momentum > 0);
  setMetric('scoreVol', scoreObj.volume, scoreObj.volume > 0);
  setMetric('scoreRS', scoreObj.rs, scoreObj.rs > 0);

  const sBadge = document.getElementById('stageBadge');
  if (sBadge) {
    sBadge.innerText = `Stage ${stage}`;
    sBadge.className = `badge ${stage === 2 ? 'badge-pass' : (stage === 4 ? 'badge-fail' : 'badge-warn')}`;
  }

  const priceEl = document.getElementById('infoPrice');
  const maLabelEl = document.getElementById('infoMALabel');
  const maValEl = document.getElementById('infoMA');
  const biasEl = document.getElementById('infoBias');

  if (priceEl) priceEl.innerText = formatPrice(last.close, state.symbol);
  if (maLabelEl) maLabelEl.innerText = `${state.maType}${state.maLen}`;
  if (maValEl) maValEl.innerText = curMA ? curMA.toFixed(2) : '-';

  const bias = curMA ? ((last.close / curMA) - 1) * 100 : 0;
  if (biasEl) {
    biasEl.innerText = bias.toFixed(2) + "%";
    biasEl.style.color = bias > 0 ? "var(--up-color)" : "var(--down-color)";
  }

  let desc;
  if (lang === 'zh') {
    desc = "資料不足，無法判讀。";
    if (stage === 1) desc = "<strong>【盤整打底】</strong>股價多在區間震盪，均線走平。此階段常為主力佈局區，但方向尚未明朗，建議耐心觀察突破方向。";
    else if (stage === 2) desc = "<strong>【多頭上升】</strong>股價突破整理區並站上均線，且均線開始走揚。這是溫斯坦理論中最理想的買進與持有階段，動能強勁。";
    else if (stage === 3) desc = "<strong>【頭部做頭】</strong>漲勢趨緩、震盪加劇，均線開始走平甚至下彎。通常是主力出貨階段，建議提高警覺，逐步減碼或拉緊停利。";
    else if (stage === 4) desc = "<strong>【空頭下跌】</strong>股價跌破長期均線且均線持續下彎。空方勢力掌控，溫斯坦建議此階段應避免持有多單，反彈皆是逃命波。";
  } else {
    desc = "Not enough data to evaluate.";
    if (stage === 1) desc = "<strong>[Stage 1 – Basing]</strong> Price is moving sideways around the long-term MA. Institutions may be accumulating, but direction is not yet clear.";
    else if (stage === 2) desc = "<strong>[Stage 2 – Advancing]</strong> Price breaks out above the base and stays above the rising MA. This is the ideal buy-and-hold phase in Weinstein's method.";
    else if (stage === 3) desc = "<strong>[Stage 3 – Topping]</strong> Uptrend slows, volatility increases and the MA flattens. Often distribution phase – tighten stops or take profits.";
    else if (stage === 4) desc = "<strong>[Stage 4 – Declining]</strong> Price falls below the long-term MA and the MA turns down. Bearish phase – rallies are usually selling opportunities.";
  }
  const stageDescEl = document.getElementById('stageDesc');
  if (stageDescEl) stageDescEl.innerHTML = desc;

  const mkItem = (labelZh, labelEn, status, detailZh, detailEn) => {
    const langNow = state.lang || 'zh';
    const label = (langNow === 'zh') ? labelZh : labelEn;
    const detail = (langNow === 'zh') ? detailZh : detailEn;
    const statusClass = status.toLowerCase();
    return `<div class="check-item-row">
      <div class="check-main-line">
        <span class="check-label">${label}</span>
        <span class="check-status status-pill status-${statusClass}">${status}</span>
      </div>
      <div class="check-desc">${detail}</div>
    </div>`;
  };

  const closeStr = formatPrice(last.close, state.symbol);
  const mansStr = (rsInfo && typeof rsInfo.mansfield === 'number')
    ? rsInfo.mansfield.toFixed(2)
    : "-";

  let clHtml = "";
  clHtml += mkItem(
    "站上主均線（> " + state.maLen + "MA）",
    "Price above " + state.maLen + "MA",
    priceAboveMA ? 'PASS' : 'FAIL',
    "股價維持在強勢區上方，趨勢良好。",
    "Price is holding in a strong zone, trend structure is healthy."
  );
  clHtml += mkItem(
    "均線方向（走揚）",
    "MA direction (turning up)",
    maUp ? 'PASS' : 'WARN',
    maUp ? "多頭動能延續。" : "均線走平或轉弱，需留意趨勢變化。",
    maUp ? "Bullish momentum intact." : "MA is flattening or turning down, watch the trend."
  );
  clHtml += mkItem(
    "量能表現",
    "Volume condition",
    isVol ? 'PASS' : 'WARN',
    isVol ? "有明顯放量支撐走勢。" : "量能普通，尚未看到明確放大。",
    isVol ? "Clear volume expansion with the move." : "Normal / light volume, no strong expansion yet."
  );
  clHtml += mkItem(
    "壓力位置（Blue Sky）",
    "Resistance / Blue-sky",
    isBlueSky ? 'PASS' : 'WARN',
    isBlueSky ? "接近或創高，壓力相對較輕。" : "靠近前高或壓力區，需留意可能的反壓。",
    isBlueSky ? "Near / new highs with lighter overhead supply." : "Close to prior highs / resistance, watch for rejection."
  );
  if (rsInfo && typeof rsInfo.mansfield === 'number') {
    clHtml += mkItem(
      "相對強度（RS）",
      "Relative strength (RS)",
      rsInfo.mansfield > 0 ? 'PASS' : 'FAIL',
      "Mansfield：" + mansStr,
      "Mansfield: " + mansStr
    );
  }
  const checklistEl = document.getElementById('checklistItems');
  if (checklistEl) checklistEl.innerHTML = clHtml;

  // Risk Management & Position Size
  const initStop = curMA ? curMA * 0.95 : 0;
  const atrVal = calcATR(stock, 14);

  const riskInitialEl = document.getElementById('riskInitial');
  const riskATRValEl = document.getElementById('valATR');

  if (riskInitialEl) {
    riskInitialEl.innerText = formatPrice(initStop, state.symbol);
    riskInitialEl.dataset.stopPrice = initStop; // store for calc
  }
  if (riskATRValEl) {
    riskATRValEl.innerText = atrVal.toFixed(3);
  }
  updatePositionSize(); // Recalc shares

  const listEl = document.getElementById('analysisList');
  if (listEl) {
    const vals = listEl.querySelectorAll('.m-item .m-val');

    const posTextZh = stage === 2 ? "多頭上升區" : (stage === 4 ? "空頭壓力區" : "整理/觀察區");
    const posTextEn = stage === 2 ? "Uptrend zone" : (stage === 4 ? "Downtrend / selling zone" : "Sideways / watch zone");
    const posText = (lang === 'zh') ? posTextZh : posTextEn;

    const volTextZh = isVol ? "放量上攻" : (last.volume < avgVol * 0.7 ? "量能偏弱" : "量能普通");
    const volTextEn = isVol ? "Strong volume breakout" : (last.volume < avgVol * 0.7 ? "Weak volume" : "Normal volume");
    const volText = (lang === 'zh') ? volTextZh : volTextEn;

    let hi = 0, lo = Number.POSITIVE_INFINITY;
    const lookback = Math.min(stock.length, 52);
    for (let i = 0; i < lookback; i++) {
      const bar = stock[stock.length - 1 - i];
      if (!bar) continue;
      if (bar.high > hi) hi = bar.high;
      if (bar.low < lo) lo = bar.low;
    }
    const distHigh = hi ? ((hi - last.close) / last.close) * 100 : NaN;
    const distLow = lo < 1e20 ? ((last.close - lo) / last.close) * 100 : NaN;

    let rsTextZh = "資料不足";
    let rsTextEn = "Not enough data";
    if (rsInfo && typeof rsInfo.mansfield === 'number') {
      if (rsInfo.mansfield > 0) {
        rsTextZh = `M=${rsInfo.mansfield.toFixed(2)}`;
        rsTextEn = `M=${rsInfo.mansfield.toFixed(2)}`;
      } else {
        rsTextZh = `M=${rsInfo.mansfield.toFixed(2)}`;
        rsTextEn = `M=${rsInfo.mansfield.toFixed(2)}`;
      }
    }
    
    // Append RSI info
    const lastRSI = state.dataCache.rsi.length > 0 ? state.dataCache.rsi[state.dataCache.rsi.length-1].value : 0;
    const rsText = `${(lang === 'zh') ? rsTextZh : rsTextEn} / RSI=${lastRSI.toFixed(0)}`;

    // Set new MA Align Value
    const maAlignEl = document.getElementById('maAlignVal');
    if (maAlignEl) {
        maAlignEl.innerText = (lang === 'zh') ? maAlignLabelZh : maAlignLabelEn;
        maAlignEl.style.color = maAlignColor;
    }

    if (vals[0]) vals[0].innerText = (lang === 'zh') ? maAlignLabelZh : maAlignLabelEn; // Replace 'maAlign'
    if (vals[1]) vals[1].innerText = posText;
    if (vals[2]) vals[2].innerText = bias.toFixed(2) + "%";
    if (vals[3]) vals[3].innerText = !Number.isNaN(distHigh) ? distHigh.toFixed(2) + "%" : "-";
    if (vals[4]) vals[4].innerText = !Number.isNaN(distLow) ? distLow.toFixed(2) + "%" : "-";
    if (vals[5]) vals[5].innerText = volText;
    
    // START: WEIN Check RS
    if (state.weinMode && (!state.dataCache.benchmark || !state.dataCache.benchmark.length)) {
      vals[6].innerText = "N/A";
    } else {
      if (vals[6]) vals[6].innerText = rsText;
    }
    // END: WEIN
  
    // Style update: Figure 4 Badge Style for "Trend & Market"
    const trendToneTag = document.getElementById('trendToneTag');
    let trendTone = 'neutral';
    if (stage === 2 && priceAboveMA && maUp) trendTone = 'bull';
    else if (stage === 4 || (!priceAboveMA && !maUp)) trendTone = 'bear';

    if (trendToneTag) {
      trendToneTag.className = 'tone-pill tone-' + trendTone;
      if (lang === 'zh') {
        trendToneTag.textContent = trendTone === 'bull' ? '偏多' : (trendTone === 'bear' ? '偏空' : '中性');
      } else {
        trendToneTag.textContent = trendTone === 'bull' ? 'Bullish' : (trendTone === 'bear' ? 'Bearish' : 'Neutral');
      }
    }

    const clearToneVal = (el) => {
      if (!el) return;
      el.classList.remove('tone-val-bull','tone-val-bear','tone-val-neutral');
    };
    vals.forEach(clearToneVal);

    if (vals[5]) { // vol
      const volTone = isVol ? 'bull' : (last.volume < avgVol * 0.7 ? 'bear' : 'neutral');
      vals[5].classList.add(volTone === 'bull' ? 'tone-val-bull' : volTone === 'bear' ? 'tone-val-bear' : 'tone-val-neutral');
    }
    if (vals[6]) { // RS
      const rsTone = (rsInfo && typeof rsInfo.mansfield === 'number' && rsInfo.mansfield > 0) ? 'bull' : 'bear';
      vals[6].classList.add(rsTone === 'bull' ? 'tone-val-bull' : 'tone-val-bear');
    }
}

  const patternEl = document.getElementById('patternTags');
  if (patternEl) {
    const tags = [];
    const n = stock.length;
    const prev = stock[n - 2];
    const prev2 = stock[n - 3];

    const trendUp = stage === 2 && priceAboveMA && maUp;
    const trendDown = stage === 4;
    const isSideways = stage === 1 && !isVol;

    if (maAlignStatus === 'Bull') {
        tags.push(lang === 'zh' ? "結構：均線多頭排列" : "Struct: Bullish MA Align");
    } else if (maAlignStatus === 'Bear') {
        tags.push(lang === 'zh' ? "結構：均線空頭排列" : "Struct: Bearish MA Align");
    }

    if (trendUp) {
      tags.push(lang === 'zh' ? "趨勢：溫斯坦多頭 (Uptrend)" : "Trend: Uptrend");
    }
    if (trendDown) {
      tags.push(lang === 'zh' ? "趨勢：溫斯坦空頭 (Downtrend)" : "Trend: Downtrend");
    }
    if (isSideways) {
      tags.push(lang === 'zh' ? "趨勢：區間盤整" : "Trend: Sideways range");
    }

    if (prev) {
      if (last.high < prev.high && last.low > prev.low) {
        tags.push(lang === 'zh' ? "K線：Inside Bar" : "Price Action: Inside Bar");
      }
      if (last.high > prev.high && last.low < prev.low) {
        tags.push(lang === 'zh' ? "K線：Outside Bar" : "Price Action: Outside Bar");
      }
      const body = Math.abs(last.close - last.open);
      const range = last.high - last.low;
      const upperWick = last.high - Math.max(last.close, last.open);
      const lowerWick = Math.min(last.close, last.open) - last.low;

      if (range > 0 && body / range < 0.1) {
        tags.push(lang === 'zh' ? "K線：十字線 (Doji)" : "Price Action: Doji");
      }
      if (range > 0 && body / range < 0.3) {
        if (lowerWick > body * 2 && upperWick < body) {
          tags.push(lang === 'zh' ? "K線：Hammer / 下影線反轉" : "Price Action: Hammer / Long lower wick");
        } else if (upperWick > body * 2 && lowerWick < body) {
          tags.push(lang === 'zh' ? "K線：Shooting Star / 上影線反轉" : "Price Action: Shooting Star");
        }
      }
      if (prev2) {
        const prevBody = Math.abs(prev.close - prev.open);
        if (body > prevBody) {
          if (last.close > last.open && prev.close < prev.open &&
              last.close >= prev.open && last.open <= prev.close) {
            tags.push(lang === 'zh' ? "K線：看多吞噬 (Bullish Engulfing)" : "Price Action: Bullish Engulfing");
          }
          if (last.close < last.open && prev.close > prev.open &&
              last.close <= prev.open && last.open >= prev.close) {
            tags.push(lang === 'zh' ? "K線：看空吞噬 (Bearish Engulfing)" : "Price Action: Bearish Engulfing");
          }
        }
      }
    }

    let recentHigh = 0, recentLow = Number.POSITIVE_INFINITY;
    const lbStruct = Math.min(stock.length, 40);
    for (let i = 0; i < lbStruct; i++) {
      const bar = stock[n - 1 - i];
      if (!bar) continue;
      if (bar.high > recentHigh) recentHigh = bar.high;
      if (bar.low < recentLow) recentLow = bar.low;
    }
    const breakoutUp = last.close > recentHigh * 1.01;
    const breakoutDown = last.close < recentLow * 0.99;

    if (breakoutUp) {
      tags.push(lang === 'zh' ? "結構：向上突破 (Breakout)" : "Structure: Bullish breakout");
    }
    if (breakoutDown) {
      tags.push(lang === 'zh' ? "結構：向下跌破" : "Structure: Bearish breakdown");
    }

    if (trendUp && prev && prev2) {
      const pulledToMA = curMA && last.low <= curMA * 1.01 && last.low >= curMA * 0.98;
      if (pulledToMA) {
        tags.push(lang === 'zh' ? "結構：多頭回測均線 (Pullback to MA)" : "Structure: Pullback to MA");
      }
    }

    const volSpike = last.volume > avgVol * 2;
    if (volSpike) {
      tags.push(lang === 'zh' ? "量價：爆量 (Volume Spike)" : "Volume: Spike");
    }

    if (prev) {
      const priceUp = last.close > prev.close;
      const volDown = last.volume < avgVol;
      if (priceUp && volDown) {
        tags.push(lang === 'zh' ? "量價：價漲量縮 (Divergence)" : "Volume: Up on weak volume");
      }
    }
    
    let bullCount = 0, bearCount = 0;
    for (const t of tags) {
      const s = String(t).toLowerCase();
      if (s.includes('多頭') || s.includes('uptrend') || s.includes('bullish') || s.includes('向上突破')) bullCount++;
      if (s.includes('空頭') || s.includes('bearish') || s.includes('跌破') || s.includes('shooting star')) bearCount++;
    }
    let patternTone = 'neutral';
    if (bullCount > bearCount && bullCount > 0) patternTone = 'bull';
    else if (bearCount > bullCount && bearCount > 0) patternTone = 'bear';

    const patternToneEl = document.getElementById('patternToneTag');
    if (patternToneEl) {
      patternToneEl.className = 'tone-pill tone-' + patternTone;
      if (lang === 'zh') {
        patternToneEl.textContent = patternTone === 'bull' ? '偏多' : (patternTone === 'bear' ? '偏空' : '中性');
      } else {
        patternToneEl.textContent = patternTone === 'bull' ? 'Bullish' : (patternTone === 'bear' ? 'Bearish' : 'Neutral');
      }
    }
    if (!tags.length) {
      patternEl.innerHTML = `<span style="font-size:12px; color:#555;">${lang === 'zh' ? "尚未偵測到明顯型態" : "No clear patterns detected"}</span>`;
    } else {
      patternEl.innerHTML = tags.map(t => `<span class="tag-pill">${t}</span>`).join(" ");
    }
  }

  const supExtEl = document.getElementById('lvlSupExt');
  const resExtEl = document.getElementById('lvlResExt');
  const vahEl = document.getElementById('lvlVAH');
  const valEl = document.getElementById('lvlVAL');
  const pocEl = document.getElementById('lvlPOC');

  if (supExtEl && resExtEl && vahEl && valEl && pocEl) {
    let hi = -1e20;
    let lo = 1e20;
    const len = Math.min(80, stock.length); 
    for (let i = stock.length - len; i < stock.length; i++) {
      const c = stock[i];
      if (!c) continue;
      if (c.high > hi) hi = c.high;
      if (c.low < lo) lo = c.low;
    }
    if (hi < -1e10) hi = null;
    if (lo > 1e10) lo = null;

    let vahPrice = null;
    let valPrice = null;
    let pocPrice = null;
    if (len > 10) {
      const slice = stock.slice(stock.length - len); 
      const highs = slice.map(c => c.high);
      const lows = slice.map(c => c.low);
      const globalHigh = Math.max(...highs);
      const globalLow = Math.min(...lows);
      const bins = 24;
      const step = (globalHigh - globalLow) / bins || 1;
      const volHist = new Array(bins).fill(0);
      for (const c of slice) {
        const mid = (c.high + c.low) / 2;
        let idx = Math.floor((mid - globalLow) / step);
        if (idx < 0) idx = 0;
        if (idx >= bins) idx = bins - 1;
        volHist[idx] += c.volume || 0;
      }
      let maxVol = -1;
      let pocIdx = 0;
      for (let i = 0; i < bins; i++) {
        if (volHist[i] > maxVol) {
          maxVol = volHist[i];
          pocIdx = i;
        }
      }
      pocPrice = globalLow + (pocIdx + 0.5) * step;

      const sorted = [...volHist].sort((a, b) => b - a);
      const cutoff = sorted[Math.min(4, sorted.length - 1)]; 
      let minIdx = bins - 1;
      let maxIdx = 0;
      for (let i = 0; i < bins; i++) {
        if (volHist[i] >= cutoff) {
          if (i < minIdx) minIdx = i;
          if (i > maxIdx) maxIdx = i;
        }
      }
      vahPrice = globalLow + (maxIdx + 0.5) * step;
      valPrice = globalLow + (minIdx + 0.5) * step;
    }

    resExtEl.innerText = hi ? formatPrice(hi, state.symbol) : "-";
    supExtEl.innerText = lo < 1e20 ? formatPrice(lo, state.symbol) : "-";
    vahEl.innerText = vahPrice ? formatPrice(vahPrice, state.symbol) : "-";
    valEl.innerText = valPrice ? formatPrice(valPrice, state.symbol) : "-";
    pocEl.innerText = pocPrice ? formatPrice(pocPrice, state.symbol) : "-";

    const srToneTag = document.getElementById('srToneTag');
    let distHigh = null;
    let distLow = null;
    if (hi && hi > 0) {
      distHigh = Math.abs((hi - last.close) / last.close) * 100;
    }
    if (lo && lo > 0) {
      distLow = Math.abs((last.close - lo) / last.close) * 100; 
    }

    const resetToneVal = (el) => {
      if (!el) return;
      el.classList.remove('tone-val-bull','tone-val-bear','tone-val-neutral');
    };
    resetToneVal(supExtEl);
    resetToneVal(resExtEl);
    resetToneVal(vahEl);
    resetToneVal(valEl);
    resetToneVal(pocEl);

    if (supExtEl) supExtEl.classList.add('tone-val-bull');
    if (valEl) valEl.classList.add('tone-val-bull');
    if (resExtEl) resExtEl.classList.add('tone-val-bear');
    if (vahEl) vahEl.classList.add('tone-val-bear');
    if (pocEl) pocEl.classList.add('tone-val-neutral');

    let srTone = 'neutral';
    if (isBlueSky) {
      srTone = 'bull';
    } else if (typeof stage === 'number' && (stage === 4 || stage === 3)) {
      if (distHigh !== null && distHigh < 8) {
        srTone = 'bear';
      } else {
        srTone = 'bear';
      }
    } else if (distHigh !== null && distHigh < 3) {
      srTone = 'bear';
    } else if (distLow !== null && distLow < 3) {
      srTone = 'bull';
    } else if (typeof stage === 'number' && stage === 2 && maUp) {
      srTone = 'bull';
    } else {
      srTone = 'neutral';
    }

    if (srToneTag) {
      srToneTag.className = 'tone-pill tone-' + srTone;
      const langNow = state.lang || 'zh';
      if (langNow === 'zh') {
        srToneTag.textContent = srTone === 'bull' ? '偏多' : (srTone === 'bear' ? '偏空' : '中性');
      } else {
        srToneTag.textContent = srTone === 'bull' ? 'Bullish' : (srTone === 'bear' ? 'Bearish' : 'Neutral');
      }
    }
  }

  state.dataCache.rsInfo = rsInfo;

  // === NEW INTEGRATION POINTS: RENDER NEW CARDS ===
  JCH_renderCard({
    stock, 
    maData, 
    rsInfo, 
    interval: state.interval, 
    lang: state.lang || 'zh'
  });

  CS_renderCard({
    stock,
    maData,
    rsInfo,
    stage,        // pass computed stage from existing logic
    priceAboveMA, // pass existing boolean
    maUp,         // pass existing boolean
    lang: state.lang || 'zh'
  });

  ENTRY_renderCard({
    stock,
    maData,
    stage,
    rsInfo,
    interval: state.interval,
    lang: state.lang || 'zh'
  });

  // START: Call new modules (需求 A & B)
  CS12_renderSetups(CS12_calcSetups(stock));
  JCH_renderPlan(stock, maData, rsInfo);
  // END: New modules

  // START: INTEGRATED_ADVICE_V2_LOGIC
  // New entry point for V2 Advice
  INTEG_renderAdvice();
  // END: INTEGRATED_ADVICE_V2_LOGIC

  // START: TRADE_PLAN_CARD_V2 CALL
  const tpContext = INTEG_collectInputs();
  if (tpContext) {
    // Set checklistPassRatio (proxy for grading)
    const checklistEl = document.getElementById('checklistItems');
    const passCount = checklistEl ? checklistEl.querySelectorAll('.status-pass').length : 0;
    const totalCount = checklistEl ? checklistEl.querySelectorAll('.check-item-row').length : 1;
    tpContext.checklistPassRatio = passCount / totalCount;
    
    const tpPlan = TP_buildTradePlan(tpContext);
    TP_renderTradePlan(tpPlan);
  }
  // END: TRADE_PLAN_CARD_V2 CALL
}

function updatePositionSize() {
  const stock = state.dataCache.stock;
  if (!stock || !stock.length) return;
  const price = stock[stock.length-1].close;
  
  // Use the stop price from the *Risk Management Card* as required for the original function
  const stopEl = document.getElementById('riskInitial');
  const stopPrice = parseFloat(stopEl ? stopEl.dataset.stopPrice : 0);
  
  const sharesEl = document.getElementById('calcShares');
  if(!sharesEl) return;

  if (stopPrice <= 0 || price <= stopPrice) {
    sharesEl.innerText = "0";
    return;
  }
  
  // Formula: (Capital * Risk%) / (Entry - Stop)
  // Use the original card's inputs for the original function's calculation
  const capital = parseFloat(document.getElementById('inputCapital').value) || 100000;
  const riskPct = parseFloat(document.getElementById('inputRiskPct').value) || 2;
  
  const riskAmt = capital * (riskPct / 100);
  const riskPerShare = price - stopPrice;
  const shares = Math.floor(riskAmt / riskPerShare);
  
  sharesEl.innerText = shares > 0 ? shares : "0";
}

function downloadCSV() {
  const stock = state.dataCache.stock;
  if (!stock || !stock.length) { alert("無資料可下載"); return; }
  
  let csvContent = "data:text/csv;charset=utf-8,";
  csvContent += "Date,Open,High,Low,Close,Volume,MA\n";
  
  const maMap = new Map(state.dataCache.ma.map(m => [m.time, m.value]));
  
  stock.forEach(row => {
    const d = new Date(row.time * 1000);
    const dateStr = d.toISOString().split('T')[0];
    const maVal = maMap.get(row.time) || "";
    csvContent += `${dateStr},${row.open},${row.high},${row.low},${row.close},${row.volume},${maVal}\n`;
  });

  const encodedUri = encodeURI(csvContent);
  const link = document.createElement("a");
  link.setAttribute("href", encodedUri);
  link.setAttribute("download", `${state.symbol}_${state.interval}_data.csv`);
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}

async function fetchYahoo(symbol, interval, range) {
  for (let proxy of PROXY_LIST) {
    try {
      const query = `https://query1.finance.yahoo.com/v8/finance/chart/${symbol}?range=${range}&interval=${interval}`;
      const url = proxy.type === 'param' ? proxy.url + encodeURIComponent(query) : proxy.url + query;
      const c = new AbortController(); setTimeout(() => c.abort(), 8000);
      const res = await fetch(url, { signal: c.signal });
      if (!res.ok) continue;
      const json = await res.json();
      const result = json.chart?.result?.[0];
      if (!result) continue;
      const t = result.timestamp || [];
      const q = result.indicators.quote[0];
      const out = [];
      for (let i = 0; i < t.length; i++) {
        if (q.close[i] != null) out.push({ time: t[i], open: q.open[i], high: q.high[i], low: q.low[i], close: q.close[i], volume: q.volume[i] || 0 });
      }
      return out;
    } catch (e) { console.warn(e); }
  }
  return null;
}

// New Fetch Profile (Removed as Sector info is removed from UI)
async function fetchYahooProfile(symbol) {
  return { sector: 'N/A' };
}

function setLoading(b) { document.getElementById('loading').style.display = b ? 'flex' : 'none'; }
function setStatus(m, e=false) { const el=document.getElementById('statusBar'); el.innerText=m; el.style.color=e?'#f23645':'#fbc02d'; }

// ===============================================
// NEW MODULE 1: JCH Strength (朱家弘強勢股判定)
// ===============================================
function JCH_calcStrength(stock, maData, rsInfo, interval) {
  if (!stock || stock.length < 20 || !maData || maData.length < 5) return null;

  const last = stock[stock.length - 1];
  const lastMA = maData[maData.length - 1].value;
  // approx 3 bars ago for MA direction
  const prevMA_3 = maData[Math.max(0, maData.length - 4)].value; 

  // Calculate Avg Vol 20 (exclude current possibly)
  let volSum = 0;
  for (let i = 1; i <= 20; i++) {
    volSum += stock[stock.length - 1 - i].volume;
  }
  const avgVol20 = volSum / 20;

  // Determine Lookback N for High
  let lookback = 50; // default for 1wk
  if (interval === '1d') lookback = 250;
  else if (interval.includes('m')) lookback = 200;
  
  let highN = 0;
  const lbIndex = Math.max(0, stock.length - lookback);
  for (let i = lbIndex; i < stock.length; i++) {
    if (stock[i].high > highN) highN = stock[i].high;
  }

  // --- Conditions ---
  // A. Price > MA
  const condA = last.close > lastMA;
  
  // B. MA Up
  const condB = lastMA > prevMA_3;
  
  // C. RS > 0
  const condC = (rsInfo && typeof rsInfo.mansfield === 'number') ? rsInfo.mansfield > 0 : false;
  
  // D. Volume > 1.5x Avg && Up Close
  const condD = (last.volume > avgVol20 * 1.5) && (last.close > last.open);
  
  // E. Near HighN (>= 0.98 * HighN)
  const condE = last.close >= highN * 0.98;

  let score = 0;
  if (condA) score += 20;
  if (condB) score += 20;
  if (condC) score += 20;
  if (condD) score += 20;
  if (condE) score += 20;

  let tone = 'Neutral';
  if (score >= 80) tone = 'Bullish';
  else if (score < 50) tone = 'Weak';

  return {
    score,
    tone,
    checks: [
      { id: 'A', pass: condA, zh: "站上均線", en: "Price > MA" },
      { id: 'B', pass: condB, zh: "均線翻揚", en: "MA Curving Up" },
      { id: 'C', pass: condC, zh: "RS 相對強勢", en: "RS > 0" },
      { id: 'D', pass: condD, zh: "放量長紅", en: "Vol > 1.5x Avg" },
      { id: 'E', pass: condE, zh: "創高或強勢", en: "Near 50-period High" }
    ]
  };
}

function JCH_renderCard(data) {
  const res = JCH_calcStrength(data.stock, data.maData, data.rsInfo, data.interval);
  const card = document.getElementById('jchCard');
  if (!res || !card) return;

  // Render Score
  const scoreEl = document.getElementById('jch_score');
  if (scoreEl) {
    scoreEl.innerText = res.score;
    scoreEl.style.color = res.score >= 80 ? 'var(--up-color)' : (res.score < 50 ? 'var(--down-color)' : '#fff');
  }

  // Render Tone
  const toneEl = document.getElementById('jch_tone');
  if (toneEl) {
    let tClass = 'tone-neutral';
    let tText = 'Neutral';
    if (res.tone === 'Bullish') { tClass = 'tone-bull'; tText = (data.lang === 'zh') ? '偏多' : 'Bullish'; }
    if (res.tone === 'Weak') { tClass = 'tone-bear'; tText = (data.lang === 'zh') ? '偏弱' : 'Weak'; }
    if (res.tone === 'Neutral') { tClass = 'tone-neutral'; tText = (data.lang === 'zh') ? '中性' : 'Neutral'; }
    
    toneEl.className = 'tone-pill ' + tClass;
    toneEl.innerText = tText;
  }

  // Render List
  const listEl = document.getElementById('jch_list');
  if (listEl) {
    let html = '';
    res.checks.forEach(c => {
      const txt = (data.lang === 'zh') ? c.zh : c.en;
      const statusClass = c.pass ? 'status-pass' : 'status-fail';
      const statusTxt = c.pass ? 'PASS' : 'FAIL';
      html += `
        <div class="jch-item">
          <span style="color:var(--text-muted);">${txt}</span>
          <span class="status-pill ${statusClass}">${statusTxt}</span>
        </div>
      `;
    });
    listEl.innerHTML = html;
  }
}

// START: 需求 B 新增 JCH Trade Plan 邏輯
function JCH_renderPlan(stock, maData) {
  const block = document.getElementById('jch_desc');
  if(!block || !stock.length || !maData.length) return;
  
  block.style.display = 'block';

  // 1. Trend Analysis (Higher High / Lower Low check last 60 bars)
  const lb = Math.min(60, stock.length);
  const data = stock.slice(-lb);
  let highs = [], lows = [];
  
  // Simple Pivot detection
  for(let i=2; i<data.length-2; i++){
    if(data[i].high > data[i-1].high && data[i].high > data[i-2].high &&
       data[i].high > data[i+1].high && data[i].high > data[i+2].high) {
       highs.push({price: data[i].high, idx: i});
    }
    if(data[i].low < data[i-1].low && data[i].low < data[i-2].low &&
       data[i].low < data[i+1].low && data[i].low < data[i+2].low) {
       lows.push({price: data[i].low, idx: i});
    }
  }
  
  // Determine Trend
  let trendStr = "盤整 / Consolidation";
  if(highs.length >= 2) {
    const lastH = highs[highs.length-1];
    const prevH = highs[highs.length-2];
    if(lastH.price > prevH.price) trendStr = "多頭浪 (Higher High)";
    else if(lastH.price < prevH.price) trendStr = "空頭浪 (Lower High)";
  }

  // 2. Pattern (Simplified)
  const last = stock[stock.length-1];
  const maVal = maData[maData.length-1].value;
  let patternStr = "整理 (Consolidation)";
  if(last.close > maVal * 1.05) patternStr = "乖離過大 (Extended)";
  else if(last.close > maVal && last.close < maVal * 1.02) patternStr = "回測支撐 (Pullback)";
  else if(last.close > maVal) patternStr = "多方行進 (Trending)";

  // 3. Entry Trigger
  // Check volume
  let volSum = 0;
  for (let i = 1; i <= 20; i++) volSum += stock[stock.length - 1 - i]?.volume || 0;
  const avgVol = volSum / 20;
  const volCond = last.volume > avgVol * 1.2;
  const triggerStr = volCond ? "量增價揚 (可關注)" : "量能不足 (觀望)";

  // 4. Stop Loss (Box Low or MA)
  // Find lowest low in last 10 bars
  let minL = 999999;
  for(let i=0; i<10; i++) {
    const l = stock[stock.length-1-i]?.low;
    if(l < minL) minL = l;
  }
  const stopPrice = Math.max(minL, maVal * 0.98); // use tighter stop

  // 5. Take Profit
  const tp1 = last.close * 1.05;
  const tp2 = last.close * 1.08;

  const lang = state.lang || 'zh';
  
  if(lang === 'zh') {
    block.innerHTML = `
      <strong>JCH 交易計畫 (Trade Plan)</strong>
      <div style="font-size:12px; margin-top:4px; color:#bbb;">
        <div>1. 趨勢：<span style="color:#fff">${trendStr}</span></div>
        <div>2. 型態：<span style="color:#fff">${patternStr}</span></div>
        <div>3. 觸發：<span style="color:${volCond ? 'var(--up-color)' : '#888'}">${triggerStr}</span></div>
        <div style="margin-top:4px; border-top:1px dashed #444; padding-top:4px;">
          <div>停損 (Stop)：<span style="color:var(--down-color)">${formatPrice(stopPrice, state.symbol)}</span> (箱底/均線)</div>
          <div>停利 (Target)：<span style="color:var(--up-color)">${formatPrice(tp1, state.symbol)} ~ ${formatPrice(tp2, state.symbol)}</span> (5-8%)</div>
        </div>
      </div>
    `;
  } else {
    block.innerHTML = `
      <strong>JCH Trade Plan</strong>
      <div style="font-size:12px; margin-top:4px; color:#bbb;">
        <div>1. Trend: <span style="color:#fff">${trendStr.split('(')[1]?.replace(')','') || trendStr}</span></div>
        <div>2. Pattern: <span style="color:#fff">${patternStr.split('(')[1]?.replace(')','') || patternStr}</span></div>
        <div>3. Trigger: <span style="color:${volCond ? 'var(--up-color)' : '#888'}">${volCond ? 'Vol Expansion' : 'Low Vol'}</span></div>
        <div style="margin-top:4px; border-top:1px dashed #444; padding-top:4px;">
          <div>Stop: <span style="color:var(--down-color)">${formatPrice(stopPrice, state.symbol)}</span></div>
          <div>Target: <span style="color:var(--up-color)">${formatPrice(tp1, state.symbol)} ~ ${formatPrice(tp2, state.symbol)}</span></div>
        </div>
      </div>
    `;
  }
}
// END: 需求 B

// ===============================================
// NEW MODULE 2: Dragon Stage (蔡森四龍階段)
// ===============================================
function CS_calcDragonStage(stock, maData, rsInfo, stage, priceAboveMA, maUp) {
  if (!stock || stock.length < 20) return null;
  const last = stock[stock.length - 1];

  // Box Top (Max close of last 20)
  let boxTop = 0;
  for (let i = 1; i <= 20; i++) {
    const c = stock[stock.length - 1 - i]?.close || 0;
    if (c > boxTop) boxTop = c;
  }
  
  let nameZh = "盤整 / 無趨勢";
  let nameEn = "Consolidation";
  let reasons = [];
  let advice = "";

  const mansfield = (rsInfo && typeof rsInfo.mansfield === 'number') ? rsInfo.mansfield : -999;

  // Logic mapping
  if (stage === 2 && priceAboveMA && mansfield > 0) {
    nameZh = "主升龍 (Advancing)";
    nameEn = "Advancing Dragon";
    reasons.push(state.lang==='zh' ? "符合溫斯坦第二階段" : "Matches Stage 2 criteria");
    reasons.push(state.lang==='zh' ? "股價位於均線之上" : "Price above MA");
    reasons.push(state.lang==='zh' ? "相對大盤強勢 (RS>0)" : "Strong relative strength");
    advice = state.lang==='zh' ? "操作建議：續抱或加碼，沿均線操作。" : "Advice: Hold or add positions. Ride the MA.";
  } else if (stage === 1 && maUp && (last.close >= boxTop * 0.98)) {
    nameZh = "起漲龍 (Starting)";
    nameEn = "Starting Dragon";
    reasons.push(state.lang==='zh' ? "均線已開始翻揚" : "MA turning up");
    reasons.push(state.lang==='zh' ? "股價接近或突破箱頂" : "Price near/breaking box top");
    reasons.push(state.lang==='zh' ? "脫離底部盤整區" : "Leaving base area");
    advice = state.lang==='zh' ? "操作建議：關注突破量能，積極佈局。" : "Advice: Watch for breakout volume. Buy candidate.";
  } else if (stage === 3 && !priceAboveMA) {
    nameZh = "反彈龍 (Rebound)";
    nameEn = "Rebound Dragon";
    reasons.push(state.lang==='zh' ? "高檔震盪後跌破" : "Breakdown from top");
    reasons.push(state.lang==='zh' ? "股價反彈未過均線" : "Bounce failed at MA");
    reasons.push(state.lang==='zh' ? "均線壓力沈重" : "MA acting as resistance");
    advice = state.lang==='zh' ? "操作建議：逢高減碼，空方思維。" : "Advice: Sell into rallies. Bearish bias.";
  } else if (stage === 4) {
    nameZh = "主跌龍 (Declining)";
    nameEn = "Declining Dragon";
    reasons.push(state.lang==='zh' ? "符合溫斯坦第四階段" : "Matches Stage 4 criteria");
    reasons.push(state.lang==='zh' ? "均線下彎助跌" : "MA declining");
    reasons.push(state.lang==='zh' ? "低點不斷破低" : "Lower lows");
    advice = state.lang==='zh' ? "操作建議：現金為王，禁止接刀。" : "Advice: Cash is king. Do not buy dips.";
  } else {
    // Default / Mixed
    reasons.push(state.lang==='zh' ? "型態不明顯" : "Pattern unclear");
    advice = state.lang==='zh' ? "操作建議：多看少做。" : "Advice: Wait and see.";
  }

  return { nameZh, nameEn, reasons, advice };
}

function CS_renderCard(data) {
  const res = CS_calcDragonStage(data.stock, data.maData, data.rsInfo, data.stage, data.priceAboveMA, data.maUp);
  if (!res) return;
  
  const stageEl = document.getElementById('cs_stage');
  const reasonEl = document.getElementById('cs_reason');
  const adviceEl = document.getElementById('cs_advice');

  if (stageEl) {
    stageEl.innerText = (data.lang === 'zh') ? res.nameZh : res.nameEn;
    // Simple coloring based on name content
    if (res.nameEn.includes("Advancing") || res.nameEn.includes("Starting")) {
      stageEl.style.color = 'var(--up-color)';
      stageEl.style.borderColor = 'var(--up-color)';
      stageEl.style.background = 'rgba(8, 153, 129, 0.1)';
    } else if (res.nameEn.includes("Declining")) {
      stageEl.style.color = 'var(--down-color)';
      stageEl.style.borderColor = 'var(--down-color)';
      stageEl.style.background = 'rgba(242, 54, 69, 0.1)';
    } else {
      stageEl.style.color = '#ccc';
      stageEl.style.borderColor = '#555';
      stageEl.style.background = 'transparent';
    }
  }

  if (reasonEl) {
    reasonEl.innerHTML = res.reasons.map(r => `<li>${r}</li>`).join('');
  }

  if (adviceEl) {
    adviceEl.innerText = res.advice;
  }
}

// START: 需求 A 新增 CS 12 Setups 邏輯
function CS12_calcSetups(stock) {
  if(!stock || stock.length < 50) return { candidates: [] };
  
  const last = stock[stock.length-1];
  const scanLen = 40;
  const data = stock.slice(-scanLen);
  
  // Find min/max
  let minPrice = 999999, maxPrice = 0;
  for(let d of data) {
    if(d.low < minPrice) minPrice = d.low;
    if(d.high > maxPrice) maxPrice = d.high;
  }
  
  // Basic Candidates Logic (Simplified Detection)
  let candidates = [];
  let neckline = maxPrice; // Default resistance
  let rangeHeight = maxPrice - minPrice;
  let invalidation = minPrice;
  
  // 1. W Bottom Candidate: Close near max, recent min was held twice (heuristic)
  // Simplified: If close is in upper 20% of range and Range > 5%
  const isHighRange = (last.close - minPrice) / (maxPrice - minPrice) > 0.8;
  const isDeep = (maxPrice - minPrice) / minPrice > 0.05;
  
  if(isHighRange && isDeep) {
    candidates.push("W底 / 破底翻 (W-Bottom)");
    neckline = maxPrice;
    rangeHeight = maxPrice - minPrice;
    invalidation = minPrice;
  }
  
  // 2. Consolidation / Triangle
  // If close is middle of range
  const isMidRange = Math.abs((last.close - minPrice)/(maxPrice - minPrice) - 0.5) < 0.2;
  if(isMidRange && isDeep) {
    candidates.push("收斂整理 (Triangle)");
    neckline = maxPrice; // Breakout point
    invalidation = minPrice;
  }
  
  // 3. Island Reversal (Gap check)
  const prev = stock[stock.length-2];
  if (prev && last.low > prev.high) {
    candidates.push("島型反轉 (Island)");
    neckline = last.low; // The gap
    invalidation = prev.high; // Gap fill
  }

  if(candidates.length === 0) {
    candidates.push("箱型整理 (Box)");
    neckline = maxPrice;
  }
  
  return {
    candidates: candidates.slice(0, 3),
    neckline,
    rangeHeight,
    targetUp: neckline + rangeHeight,
    targetDown: neckline - rangeHeight,
    invalidation
  };
}

function CS12_renderSetups(result) {
  const block = document.getElementById('cs12_setup_block');
  if(!block) return;
  block.style.display = 'block';
  
  const lang = state.lang || 'zh';
  const cands = result.candidates.join(", ");
  const neck = formatPrice(result.neckline, state.symbol);
  const target = formatPrice(result.targetUp, state.symbol);
  const inval = formatPrice(result.invalidation, state.symbol);
  
  if(lang === 'zh') {
    block.innerHTML = `
      <strong title="基於公開技術分析概念彙整，非任何個人/機構之官方內容">Setups 模組 (S12)</strong>
      <div style="font-size:12px; margin-top:4px; color:#bbb;">
        <div>候選：<span style="color:#fff">${cands}</span></div>
        <div>頸線：<span style="color:var(--accent-color)">${neck}</span></div>
        <div>測幅：<span style="color:var(--up-color)">${target}</span> (等幅)</div>
        <div>失效：<span style="color:var(--down-color)">跌破 ${inval}</span></div>
      </div>
    `;
  } else {
    block.innerHTML = `
      <strong title="Based on public technical-analysis concepts. Not affiliated.">Setups Module (S12)</strong>
      <div style="font-size:12px; margin-top:4px; color:#bbb;">
        <div>Patterns: <span style="color:#fff">${cands}</span></div>
        <div>Neckline: <span style="color:var(--accent-color)">${neck}</span></div>
        <div>Target: <span style="color:var(--up-color)">${target}</span></div>
        <div>Invalid: <span style="color:var(--down-color)">Below ${inval}</span></div>
      </div>
    `;
  }
}
// END: 需求 A

// ===============================================
// NEW MODULE 3: Entry Zone (出手價建議)
// ===============================================
function ENTRY_calcZones(stock, maData, interval, stage, rsInfo) {
  if (!stock || stock.length < 50) return null;

  // Determine Lookback
  let lookback = 50; 
  if (interval === '1d') lookback = 250;
  if (interval.includes('m')) lookback = 200;

  // 1. Resistance (Max High)
  let resistance = 0;
  const lbIndex = Math.max(0, stock.length - lookback);
  for (let i = lbIndex; i < stock.length; i++) {
    if (stock[i].high > resistance) resistance = stock[i].high;
  }

  // 2. Box Top (Max Close 20)
  let boxTop = 0;
  for (let i = 1; i <= 20; i++) {
    const c = stock[stock.length - 1 - i]?.close || 0;
    if (c > boxTop) boxTop = c;
  }

  // 3. Breakout Price
  const breakoutPrice = Math.max(resistance, boxTop);
  
  // 4. Pullback Zone (Breakout +/- 2%)
  const zoneLow = breakoutPrice * 0.98;
  const zoneHigh = breakoutPrice * 1.02;

  // 5. Entry Type Logic
  const last = stock[stock.length - 1];
  let type = 'Neutral'; // Breakout, Pullback, Avoid
  let typeZh = '觀望';
  let typeEn = 'Wait';
  let noteZh = '';
  let noteEn = '';
  let tone = 'neutral';

  const mansfield = (rsInfo && typeof rsInfo.mansfield === 'number') ? rsInfo.mansfield : 0;

  // Avoid conditions
  if (stage === 4 || (stage === 3 && last.close < maData[maData.length-1].value)) {
    type = 'Avoid';
    typeZh = '不建議';
    typeEn = 'Avoid';
    tone = 'bear';
    noteZh = '處於下跌或頭部階段，風險過高。';
    noteEn = 'High risk. Downtrend or topping structure.';
  } else if (mansfield < -5) {
    type = 'Avoid';
    typeZh = '不建議';
    typeEn = 'Avoid';
    tone = 'bear';
    noteZh = '相對強度過弱，資金未青睞。';
    noteEn = 'Relative strength too weak.';
  } else {
    // Bullish scenarios
    if (last.close >= breakoutPrice) {
      type = 'Breakout';
      typeZh = '突破追價';
      typeEn = 'Breakout';
      tone = 'bull';
      noteZh = '股價創高，動能強勁，可嘗試追價。';
      noteEn = 'Price breaking out. Momentum strong.';
    } else if (last.close >= zoneLow && last.close <= zoneHigh) {
      type = 'Pullback';
      typeZh = '回測承接';
      typeEn = 'Pullback';
      tone = 'bull';
      noteZh = '股價位於突破點附近，可逢低佈局。';
      noteEn = 'Price near breakout level. Buy the dip.';
    } else if (last.close < zoneLow) {
      type = 'Wait';
      typeZh = '等待突破';
      typeEn = 'Wait';
      tone = 'neutral';
      noteZh = `尚未突破關鍵價位 ${formatPrice(breakoutPrice, state.symbol)}。`;
      noteEn = `Below key level ${formatPrice(breakoutPrice, state.symbol)}.`;
    }
  }

  return {
    zoneLow,
    zoneHigh,
    typeZh,
    typeEn,
    tone,
    noteZh,
    noteEn,
    breakoutPrice // Pass the raw price for TP module to use
  };
}

function ENTRY_renderCard(data) {
  const res = ENTRY_calcZones(data.stock, data.maData, data.interval, data.stage, data.rsInfo);
  if (!res) return;

  const typeEl = document.getElementById('entry_type');
  const zoneEl = document.getElementById('entry_zone');
  const riskEl = document.getElementById('entry_risk');

  if (typeEl) {
    typeEl.className = 'tone-pill tone-' + res.tone;
    typeEl.innerText = (data.lang === 'zh') ? res.typeZh : res.typeEn;
  }

  if (zoneEl) {
    zoneEl.innerText = `${formatPrice(res.zoneLow, state.symbol)} ~ ${formatPrice(res.zoneHigh, state.symbol)}`;
  }

  if (riskEl) {
    riskEl.innerText = (data.lang === 'zh') ? res.noteZh : res.noteEn;
  }
}

// START: INTEGRATED_ADVICE_V2_LOGIC
// This function definition is moved outside of INTEG_renderAdvice for global access
function calcStructureStop(inputs, regime) {
  if (!inputs) return { price: null, source: 'No Inputs' };
  const { lastClose, cs12Res, entryZoneLow } = inputs;
  const stock = state.dataCache.stock;
  
  let stop = null;
  let source = '';

  if (regime === 'LONG' || regime === 'WAIT') {
    // 1. CS12 Invalidation (Neckline support in pullback or box bottom)
    if (cs12Res && cs12Res.invalidation && cs12Res.invalidation < lastClose) {
      stop = cs12Res.invalidation;
      source = 'CS Invalidation';
    }
    // 2. Entry Zone Low
    else if (entryZoneLow > 0 && entryZoneLow < lastClose) {
      stop = entryZoneLow * 0.99; // tiny buffer
      source = 'Zone Low';
    }
    // 3. Recent Swing Low (20 bars)
    else {
      let minL = Infinity;
      const lb = Math.min(stock.length, 20);
      for(let i=0; i<lb; i++) {
        const l = stock[stock.length - 1 - i].low;
        if(l < minL) minL = l;
      }
      if(minL < lastClose) {
        stop = minL;
        source = 'Swing Low (20)';
      }
    }
  } else if (regime === 'SHORT') {
    // For Short, stop must be ABOVE last close (Resistance)
    // 1. CS12 Neckline (Resistance)
    if (cs12Res && cs12Res.neckline && cs12Res.neckline > lastClose) {
      stop = cs12Res.neckline * 1.002;
      source = 'CS Resistance';
    }
    // 2. Entry Zone High (if broken above)
    else if (inputs.entryZoneHigh > 0 && inputs.entryZoneHigh > lastClose) {
      stop = inputs.entryZoneHigh * 1.01;
      source = 'Zone High';
    }
    // 3. Recent Swing High
    else {
      let maxH = 0;
      const lb = Math.min(stock.length, 20);
      for(let i=0; i<lb; i++) {
        const h = stock[stock.length - 1 - i].high;
        if(h > maxH) maxH = h;
      }
      if(maxH > lastClose) {
        stop = maxH;
        source = 'Swing High (20)';
      }
    }
  }
  
  return { price: stop, source };
}

function INTEG_collectInputs() {
  const { stock, ma, rsInfo } = state.dataCache;
  if (!stock || stock.length === 0) return null;

  const lastBar = stock[stock.length - 1];
  const lastMA = (ma && ma.length > 0) ? ma[ma.length - 1].value : null;

  // Use state.weinStage calculated from weekly logic (or local stage)
  let stage = state.weinStage; 
  // Re-calc helper context for standard mode
  const curMA = lastMA;
  const prevMA = (ma && ma.length > 4) ? ma[ma.length - 5].value : lastMA;
  const maUp = (curMA && prevMA) ? curMA > prevMA : false;
  const priceAboveMA = curMA ? lastBar.close > curMA : false;
  
  if (!state.weinMode) {
    // Re-derive standard stage for context
    if (priceAboveMA && maUp) stage = 2;
    else if (!priceAboveMA && !maUp) stage = 4;
    else if (!priceAboveMA && maUp) stage = 3;
    else stage = 1;
  }

  // JCH
  const jchRes = JCH_calcStrength(stock, ma, rsInfo, state.interval);
  // Dragon
  const dragonRes = CS_calcDragonStage(stock, ma, rsInfo, stage, priceAboveMA, maUp);
  // Entry
  const entryRes = ENTRY_calcZones(stock, ma, state.interval, stage, rsInfo);
  // CS12
  const cs12Res = CS12_calcSetups(stock);

  // Momentum Score (from DOM is easiest as it's complex calc)
  const momScoreEl = document.getElementById('scoreVal');
  const momentumScore = momScoreEl ? parseInt(momScoreEl.innerText) : 50;

  // Risk (using risk management card stop price as trend stop proxy)
  const stopEl = document.getElementById('riskInitial');
  let stopPrice = lastBar.close * 0.95;
  if (stopEl && stopEl.innerText !== '-') stopPrice = parseFloat(stopEl.dataset.stopPrice);
  
  // Checklist Pass Ratio calculation is added inside updateAnalysisPanel before calling TP

  return {
    symbol: state.symbol,
    maType: state.maType,
    maLen: state.maLen,
    lastClose: lastBar.close,
    weinStageWeekly: stage, // 1,2,3,4
    rsMansfield: (rsInfo && rsInfo.mansfield) ? rsInfo.mansfield : 0,
    momentumScore,
    jchScore: jchRes ? jchRes.score : 0,
    dragonStage: dragonRes ? dragonRes.nameZh : '',
    entryType: entryRes ? entryRes.typeEn : 'Neutral', // Breakout, Pullback, Wait, Avoid
    entryZoneHigh: entryRes ? entryRes.zoneHigh : 0,
    entryZoneLow: entryRes ? entryRes.zoneLow : 0,
    breakoutPrice: entryRes ? entryRes.breakoutPrice : 0, // Use explicit breakout price
    stopPrice, // Trend stop proxy
    lastMA: lastMA, // For trend stop
    cs12Res: cs12Res, // For structure stop (invalidation)
    cs12Candidates: cs12Res ? cs12Res.candidates : [],
    checklistPassRatio: 0.5 // Default placeholder, updated in updateAnalysisPanel caller
  };
}

function INTEG_decideRegime(inputs) {
  if (!inputs) return { regime: 'NO_DATA', reason: '無資料' };
  
  const { weinStageWeekly, rsMansfield } = inputs;
  
  // Gate: Weinstein Stage
  if (weinStageWeekly === 2) {
    return { regime: 'LONG', reason: 'Stage 2 多頭階段' };
  } else if (weinStageWeekly === 4) {
    return { regime: 'SHORT', reason: 'Stage 4 空頭階段' };
  } else if (weinStageWeekly === 3 && rsMansfield > 0) {
    return { regime: 'WAIT', reason: 'Stage 3 頭部震盪' }; 
  } else {
    // Stage 1 or Stage 3 (weak RS)
    return { regime: 'WAIT', reason: 'Stage 1/3 盤整/頭部' };
  }
}

function INTEG_score(inputs, regime) {
  if (!inputs) return { score: 0, confidence: 'Low' };
  
  const { rsMansfield, momentumScore, jchScore } = inputs;
  
  // Base score from Momentum + JCH
  let baseScore = (momentumScore * 0.5) + (jchScore * 0.5);
  
  // Adjust by Regime & RS
  if (regime === 'LONG') {
    if (rsMansfield > 0) baseScore += 10;
    else baseScore -= 15;
  } else if (regime === 'SHORT') {
    if (rsMansfield < 0) baseScore += 10;
    else baseScore -= 15;
    
    // Invert score perception for Short (High score = Good Short)
    baseScore = 100 - baseScore; 
  } else {
    baseScore = 50; 
  }
  
  baseScore = Math.max(0, Math.min(100, baseScore));
  
  let conf = 'Medium';
  if (baseScore > 75) conf = 'High';
  if (baseScore < 40) conf = 'Low';
  
  return { score: Math.floor(baseScore), confidence: conf };
}

const INTEG_templates = {
  // --- LONG TEMPLATES ---
  LONG_STRONG: {
    zh: [
      "現在環境：處於溫斯坦第二階段 (Stage 2)，且相對強度 (RS) 轉強。",
      "操作建議：趨勢明確，建議順勢操作。若有回測均線不破，可視為加碼機會。",
      "風控提醒：嚴守移動停損，切勿猜頭。"
    ],
    en: [
      "Context: Stage 2 uptrend established with positive RS.",
      "Plan: Trend is strong. Buy dips or hold. Add on pullbacks to MA.",
      "Risk: Trail your stops. Do not top-pick."
    ]
  },
  LONG_WAIT_BREAKOUT: {
    zh: [
      "現在環境：雖然多頭結構成形，但尚未突破關鍵壓力區。",
      "操作建議：別急著追價。等待收盤價明確站上壓力區後再進場。",
      "風控提醒：若突破失敗回跌，需重新評估。"
    ],
    en: [
      "Context: Bullish structure but facing overhead resistance.",
      "Plan: Be patient. Wait for a confirmed breakout close before entering.",
      "Risk: False breakout risk. Wait for confirmation."
    ]
  },
  LONG_WEAK_RS: {
    zh: [
      "現在環境：股價上漲但相對強度 (RS) 落後大盤。",
      "操作建議：動能不足，建議縮小部位或換股操作。",
      "風控提醒：漲勢可能隨時停滯，停損需設緊。"
    ],
    en: [
      "Context: Price rising but lagging the market (Weak RS).",
      "Plan: Momentum is weak. Use small size or find stronger leaders.",
      "Risk: Rally may stall. Tighten stops."
    ]
  },
  
  // --- SHORT TEMPLATES ---
  SHORT_BREAKDOWN: {
    zh: [
      "現在環境：進入溫斯坦第四階段 (Stage 4)，均線下彎助跌。",
      "操作建議：空方趨勢確立。反彈至均線遇壓時，是理想空點。",
      "風控提醒：切勿抄底。若站回均線之上則空單需停損。"
    ],
    en: [
      "Context: Stage 4 downtrend. MA is declining.",
      "Plan: Bearish trend. Sell rallies into resistance.",
      "Risk: Do not buy the dip. Cover if price reclaims MA."
    ]
  },
  SHORT_WATCH: {
    zh: [
      "現在環境：高檔轉弱 (Stage 3/4 交界)，頭部型態浮現。",
      "操作建議：多單應出場觀望。若跌破頸線支撐，可嘗試佈局空單。",
      "風控提醒：若未跌破支撐，可能維持震盪，不宜過度躁進。"
    ],
    en: [
      "Context: Topping structure (Stage 3/4 transition).",
      "Plan: Exit longs. Look to short only on breakdown of support.",
      "Risk: Chop risk inside the range. Wait for breakdown."
    ]
  },
  
  // --- WAIT/DEFENSE ---
  WAIT_DEFAULT: {
    zh: [
      "現在環境：股價處於盤整區間，方向未明。",
      "操作建議：多看少做。等待突破或跌破區間後再順勢操作。",
      "風控提醒：區間震盪容易雙巴，保留現金為上策。"
    ],
    en: [
      "Context: Price is consolidating sideways.",
      "Plan: Patience. Wait for a clear break of the range.",
      "Risk: Whipsaw risk high. Cash is king."
    ]
  }
};

function INTEG_buildAdvice(inputs) {
  const { regime } = INTEG_decideRegime(inputs);
  const { score, confidence } = INTEG_score(inputs, regime);
  
  let tpl = INTEG_templates.WAIT_DEFAULT;
  let tone = 'Neutral';
  
  if (regime === 'LONG') {
    tone = 'Bullish';
    if (inputs.entryType === 'Wait') tpl = INTEG_templates.LONG_WAIT_BREAKOUT;
    else if (inputs.rsMansfield < 0) tpl = INTEG_templates.LONG_WEAK_RS;
    else tpl = INTEG_templates.LONG_STRONG;
  } else if (regime === 'SHORT') {
    tone = 'Bearish';
    if (score > 60) tpl = INTEG_templates.SHORT_BREAKDOWN;
    else tpl = INTEG_templates.SHORT_WATCH;
  } else {
    tone = 'Neutral'; // WAIT or DEFENSE
  }
  
  // Override Tone text if needed
  let toneZh = '中性觀察';
  if (tone === 'Bullish') toneZh = '偏多操作';
  if (tone === 'Bearish') toneZh = '偏空防守';

  return {
    tone,
    toneZh,
    score,
    tpl
  };
}

function INTEG_renderAdvice() {
  const inputs = INTEG_collectInputs();
  if (!inputs) return; // Not ready
  
  const advice = INTEG_buildAdvice(inputs);
  const lang = state.lang || 'zh';
  const tplText = lang === 'zh' ? advice.tpl.zh : advice.tpl.en;
  
  // Render
  const card = document.getElementById('integratedCard');
  if (!card) return;
  
  const toneEl = document.getElementById('integratedTone');
  const sumEl = document.getElementById('integratedSummary');
  const listEl = document.getElementById('integratedReasons');
  const riskEl = document.getElementById('integratedRisk');
  
  if (toneEl) {
    let tClass = 'tone-neutral';
    if (advice.tone === 'Bullish') tClass = 'tone-bull';
    if (advice.tone === 'Bearish') tClass = 'tone-bear';
    toneEl.className = 'tone-pill ' + tClass;
    toneEl.innerText = lang === 'zh' ? advice.toneZh : advice.tone;
  }
  
  if (sumEl) {
    // 3-paragraph format
    sumEl.innerHTML = `
      <div style="margin-bottom:6px; color:#ccc;">${tplText[0]}</div>
      <div style="margin-bottom:6px; font-weight:bold; color:#fff; font-size:15px;">${tplText[1]}</div>
      <div style="color:${advice.tone==='Bearish'?'var(--down-color)':'var(--warn-color)'}; font-size:12px;">${tplText[2]}</div>
    `;
  }
  
  if (listEl) {
    // START: INTEGRATED_UPGRADE_V2 Task 1: Bilingual Reasons
    const reasons = [];
    if (lang === 'zh') {
        reasons.push(`溫斯坦：Stage ${inputs.weinStageWeekly} (週線)`);
        reasons.push(`RS Mansfield：${inputs.rsMansfield.toFixed(2)} (相對強度)`);
        reasons.push(`多空戰力：${inputs.momentumScore} (綜合動能)`);
        if (inputs.cs12Candidates.length > 0) {
            reasons.push(`形態：${inputs.cs12Candidates[0]}`);
        }
    } else {
        reasons.push(`Weinstein: Stage ${inputs.weinStageWeekly}`);
        reasons.push(`RS Mansfield: ${inputs.rsMansfield.toFixed(2)}`);
        reasons.push(`Momentum Score: ${inputs.momentumScore}`);
        if (inputs.cs12Candidates.length > 0) {
            reasons.push(`Pattern: ${inputs.cs12Candidates[0]}`);
        }
    }
    listEl.innerHTML = reasons.map(r => `<li>${r}</li>`).join('');
    // END: INTEGRATED_UPGRADE_V2
  }
  
  if (riskEl) {
    // START: INTEGRATED_UPGRADE_V2 Task 4: Dual Risk
    const { regime } = INTEG_decideRegime(inputs);
    const structStop = calcStructureStop(inputs, regime);
    
    // Trend Stop Logic (Long vs Short)
    let trendStopPrice = inputs.lastMA * 0.95; // Default Long
    let trendSource = `${inputs.maType}${inputs.maLen} x 0.95`;
    
    if (regime === 'SHORT') {
        trendStopPrice = inputs.lastMA * 1.05;
        trendSource = `${inputs.maType}${inputs.maLen} x 1.05`;
    }
    
    const sStopVal = structStop && structStop.price ? formatPrice(structStop.price, state.symbol) : "N/A";
    const tStopVal = formatPrice(trendStopPrice, state.symbol);
    const sSource = structStop ? structStop.source : "None";

    let html = "";
    if (lang === 'zh') {
        html += `<div><strong>結構停損 (進場失效)：</strong><span style="color:${regime==='SHORT'?'var(--up-color)':'var(--down-color)'}">${sStopVal}</span> <span class="hint" style="display:inline; margin:0;">(${sSource})</span></div>`;
        html += `<div><strong>趨勢停損 (持有防守)：</strong><span style="color:#fff">${tStopVal}</span> <span class="hint" style="display:inline; margin:0;">(${trendSource})</span></div>`;
    } else {
        html += `<div><strong>Structure Stop (Invalidation):</strong> <span style="color:${regime==='SHORT'?'var(--up-color)':'var(--down-color)'}">${sStopVal}</span> <span class="hint" style="display:inline; margin:0;">(${sSource})</span></div>`;
        html += `<div><strong>Trend Stop (Defense):</strong> <span style="color:#fff">${tStopVal}</span> <span class="hint" style="display:inline; margin:0;">(${trendSource})</span></div>`;
    }
    riskEl.innerHTML = html;
    // END: INTEGRATED_UPGRADE_V2
  }
}
// END: INTEGRATED_ADVICE_V2_LOGIC

// START: TRADE_PLAN_CARD_V2 CORE LOGIC
const TP_CONSTANTS = {
  BREAKOUT_CONFIRM_BARS: 2,
  BREAKOUT_BUFFER_PCT: 0.002,
  BREAKOUT_VOL_MULT: 1.3,
  PULLBACK_HOLD_BARS: 2,
  PULLBACK_BUFFER_PCT: 0.002,
  RISK_MAX_PCT: 0.08,
  VOL_AVG_LEN: 20
};

// Replicate TP_decideRegime logic for trigger calculation
function TP_decideRegime(inputs) {
  if (!inputs) return { regime: 'NO_DATA', reason: '無資料' };
  
  const { weinStageWeekly } = inputs;
  
  if (weinStageWeekly === 2) return { regime: 'LONG', reason: 'Stage 2 多頭階段' };
  if (weinStageWeekly === 4) return { regime: 'SHORT', reason: 'Stage 4 空頭階段' };
  return { regime: 'WAIT', reason: 'Stage 1/3 盤整/頭部' };
}

// 4. TP_calcTriggers: Breakout/Pullback/Second Breakout
function TP_calcTriggers(inputs) {
  const stock = state.dataCache.stock;
  if (!stock || stock.length < 2) return { trigger: 'None', details: {} };
  
  const lastBar = stock[stock.length - 1];
  const lastClose = lastBar.close;
  
  // 4.1 breakoutLevel selection (Priority: breakoutPrice > entryZoneHigh > CS Key Levels)
  let breakoutLevel = inputs.breakoutPrice || inputs.entryZoneHigh;
  const csKeyLevels = inputs.cs12Res || {};
  if (!breakoutLevel) breakoutLevel = csKeyLevels.neckline || csKeyLevels.targetUp; 
  if (!breakoutLevel) return { trigger: 'None', details: {} };
  
  // 4.3 holdLevel selection (for Pullback)
  let holdLevel = inputs.entryZoneLow;
  const structStopRes = calcStructureStop(inputs, TP_decideRegime(inputs).regime);
  if (!holdLevel) holdLevel = structStopRes.price;
  if (!holdLevel) holdLevel = csKeyLevels.invalidation; 
  
  // --- Calculate Avg Vol 20 (from JCH logic proxy) ---
  let volSum = 0, volCnt = 0;
  for (let i = 1; i <= TP_CONSTANTS.VOL_AVG_LEN; i++) {
    const bar = stock[stock.length - 1 - i];
    if (bar) { volSum += bar.volume; volCnt++; }
  }
  const avgVol = volCnt ? volSum / volCnt : 1;
  const volCondition = lastBar.volume >= avgVol * TP_CONSTANTS.BREAKOUT_VOL_MULT;
  
  // --- 4.2 Breakout Logic ---
  let confirmedCloses = 0;
  for(let i=0; i<TP_CONSTANTS.BREAKOUT_CONFIRM_BARS; i++) {
    const bar = stock[stock.length - 1 - i];
    if (bar && bar.close >= breakoutLevel * (1 + TP_CONSTANTS.BREAKOUT_BUFFER_PCT)) {
      confirmedCloses++;
    } else {
      break;
    }
  }
  const boConfirmed = confirmedCloses === TP_CONSTANTS.BREAKOUT_CONFIRM_BARS;
  const justBroke = lastClose > breakoutLevel * (1 + TP_CONSTANTS.BREAKOUT_BUFFER_PCT);
  const boUnconfirmed = justBroke && !boConfirmed;
  
  // --- 4.4 Second Breakout Logic (Pre-check) ---
  let priorPullback = false;
  const pullbackVicinity = breakoutLevel * (1 - TP_CONSTANTS.PULLBACK_BUFFER_PCT);
  for(let i=1; i<Math.min(stock.length-1, 10); i++) { // look at 10 bars back, excluding current
      const bar = stock[stock.length - 1 - i];
      if (bar && bar.low <= breakoutLevel * 1.001 && bar.low >= pullbackVicinity) {
          priorPullback = true;
          break;
      }
  }
  
  // --- Final Trigger Decision (Priority: Second BO > Confirmed BO > Pullback > Unconfirmed BO) ---
  let trigger = 'None';
  if (boConfirmed && priorPullback) {
      trigger = 'Second Breakout (Confirmed)';
  } else if (boConfirmed) {
      trigger = 'Breakout (Confirmed)';
  } else if (boUnconfirmed) {
      trigger = 'Breakout (Unconfirmed)';
  }
  
  // --- 4.3 Pullback Logic (If not already Breakout) ---
  if (trigger === 'None' && holdLevel && holdLevel < lastClose) {
      let pullHoldCount = 0;
      for(let i=0; i<TP_CONSTANTS.PULLBACK_HOLD_BARS; i++) {
          const bar = stock[stock.length - 1 - i];
          if (bar && bar.low >= holdLevel * (1 - TP_CONSTANTS.PULLBACK_BUFFER_PCT)) {
              pullHoldCount++;
          } else {
              break;
          }
      }
      const pullHeld = pullHoldCount === TP_CONSTANTS.PULLBACK_HOLD_BARS;
      const isStrong = inputs.rsMansfield > 0 || inputs.momentumScore >= 60 || inputs.checklistPassRatio >= 0.6;
      
      if (pullHeld && isStrong) {
          trigger = 'Pullback (Accepted)';
      } else if (pullHeld) {
          trigger = 'Pullback (Waiting Strength)';
      }
  }
  
  const details = {
    breakoutLevel: breakoutLevel,
    holdLevel: holdLevel,
    closesAbove: `${confirmedCloses}/${TP_CONSTANTS.BREAKOUT_CONFIRM_BARS}`,
    volMult: volCondition ? `Pass ${TP_CONSTANTS.BREAKOUT_VOL_MULT}x` : 'Fail Vol',
    priorPullback: priorPullback ? 'Yes' : 'No'
  };
  
  return { trigger, details };
}

// 6. TP_calcPositionSizing
function TP_calcPositionSizing(inputs, capital, riskPct) {
  const { lastClose } = inputs;
  
  const regime = TP_decideRegime(inputs).regime;
  const structStopRes = calcStructureStop(inputs, regime);
  
  const stopPriceForSizing = structStopRes.price;
  
  // Get Entry Price
  let entryPrice = lastClose; 
  let entrySourceZh = '未觸發 (估算現價)';
  let entrySourceEn = 'No Trigger (Estimate)';

  const trigger = inputs.triggerRes.trigger;
  const details = inputs.triggerRes.details;

  if (trigger.includes('Breakout')) {
    entryPrice = details.breakoutLevel * (1 + TP_CONSTANTS.BREAKOUT_BUFFER_PCT);
    entrySourceZh = `突破價 (${formatPrice(entryPrice, inputs.symbol)})`;
    entrySourceEn = `Breakout Price (${formatPrice(entryPrice, inputs.symbol)})`;
  } else if (trigger.includes('Pullback')) {
    entryPrice = details.holdLevel * (1 + TP_CONSTANTS.BREAKOUT_BUFFER_PCT);
    entrySourceZh = `回測價 (${formatPrice(entryPrice, inputs.symbol)})`;
    entrySourceEn = `Pullback Price (${formatPrice(entryPrice, inputs.symbol)})`;
  }

  // --- Calculations ---
  if (!stopPriceForSizing) {
    return { shares: 0, perShareRisk: 0, riskDollar: 0, positionDollar: 0, stopValid: false, entryPrice, entrySourceZh, entrySourceEn };
  }
  
  let perShareRisk = 0;
  if (regime === 'SHORT') {
    perShareRisk = stopPriceForSizing - entryPrice; // For short, stop is higher than entry
  } else {
    perShareRisk = entryPrice - stopPriceForSizing; // For long, entry is higher than stop
  }
  
  if (perShareRisk <= 0) {
    return { shares: 0, perShareRisk: perShareRisk, riskDollar: 0, positionDollar: 0, stopValid: false, entryPrice, entrySourceZh, entrySourceEn };
  }
  
  const riskDollar = capital * (riskPct / 100);
  const shares = Math.floor(riskDollar / perShareRisk);
  const positionDollar = shares * entryPrice;
  
  return { shares, perShareRisk, riskDollar, positionDollar, stopValid: true, entryPrice, entrySourceZh, entrySourceEn };
}

// 7. TP_calcRR
function TP_calcRR(inputs, entryPrice, stopPrice) {
  // Target Selection (7)
  let targetPrice = null;
  let targetSourceZh = '無目標：僅供觀察';
  let targetSourceEn = 'No Target: Observation only';
  
  const cs12Res = inputs.cs12Res || {};
  
  // 1. Target Zone High (from ENTRY module or proxy)
  if (inputs.entryZoneHigh > 0 && inputs.entryZoneHigh > entryPrice * 1.01) {
      targetPrice = inputs.entryZoneHigh;
      targetSourceZh = '壓力區上緣';
      targetSourceEn = 'Target Zone High';
  }
  // 2. CS12 Measured Move (Target Up)
  else if (cs12Res.targetUp > entryPrice * 1.01) { 
    targetPrice = cs12Res.targetUp;
    targetSourceZh = '形態測幅目標';
    targetSourceEn = 'Pattern Target';
  }
  // 3. 52-week High (proxy)
  else {
      let hi = 0;
      const lb = Math.min(state.dataCache.stock.length, 52);
      for (let i = 0; i < lb; i++) {
        const bar = state.dataCache.stock[state.dataCache.stock.length - 1 - i];
        if (!bar) continue;
        if (bar.high > hi) hi = bar.high;
      }
      if (hi > entryPrice * 1.01) {
          targetPrice = hi;
          targetSourceZh = '52週高點';
          targetSourceEn = '52Wk High';
      }
  }

  // Calculation (Use magnitude)
  let risk = 0, reward = 0, rr = null;
  
  if (entryPrice && stopPrice && targetPrice) {
    const riskMag = Math.abs(entryPrice - stopPrice);
    const rewardMag = Math.abs(targetPrice - entryPrice);
    
    risk = riskMag;
    reward = rewardMag;
    rr = risk > 0 ? reward / risk : null;
  }

  return { targetPrice, targetSourceZh, targetSourceEn, risk, reward, rr };
}

// 8. TP_calcGrade
function TP_calcGrade(inputs, plan) {
  const { weinStageWeekly, rsMansfield } = inputs;
  const { riskDistPct, triggerRes, structStopRes, rrRes } = plan;
  const { trigger } = triggerRes;
  const { rr } = rrRes;
  
  const riskPass = riskDistPct <= TP_CONSTANTS.RISK_MAX_PCT;
  const structStopValid = structStopRes.price !== null;
  
  const reasons = [];
  
  // C - Avoid conditions
  if (weinStageWeekly === 4) { reasons.push('Stage 4 (空頭階段)'); }
  if (rsMansfield < 0) { reasons.push('RS < 0 (相對弱勢)'); }
  if (!structStopValid) { reasons.push('Structure Stop 無效'); }
  if (riskDistPct > TP_CONSTANTS.RISK_MAX_PCT) { reasons.push(`風險距離 > ${TP_CONSTANTS.RISK_MAX_PCT * 100}%`); }
  if (rr !== null && rr < 2) { reasons.push('R:R < 2.0'); }
  
  // If any C reason is present, it's C grade (or fails to be A/B)
  if (reasons.length > 0) return { grade: 'C', reasons: reasons.slice(0, 3) };

  // A - Superior conditions
  let scoreA = 0;
  const A_reasons = [];
  
  if (weinStageWeekly === 2) { scoreA++; A_reasons.push('Stage 2'); }
  if (rsMansfield > 0) { scoreA++; A_reasons.push('RS > 0'); }
  if (trigger.includes('Second Breakout Confirmed') || trigger.includes('Breakout (Confirmed)')) { 
      scoreA++; 
      A_reasons.push(trigger.includes('Second Breakout') ? 'Second Breakout Confirmed' : 'Breakout Confirmed'); 
  }
  if (rr !== null && rr >= 2) { scoreA++; A_reasons.push(`R:R ${rr.toFixed(1)}`); }
  if (riskPass) { scoreA++; A_reasons.push(`風險距離 ${riskDistPct * 100 < 0.1 ? '<0.1%' : (riskDistPct * 100).toFixed(1) + '%'}`); }
  
  if (scoreA >= 4) return { grade: 'A', reasons: A_reasons.slice(0, 3) };

  // B - Common conditions
  let scoreB = 0;
  const B_reasons = [];
  if (weinStageWeekly === 1 || weinStageWeekly === 2 || weinStageWeekly === 3) { scoreB++; B_reasons.push(`Stage ${weinStageWeekly}`); }
  if (trigger.includes('Breakout (Unconfirmed)') || trigger.includes('Pullback (Accepted)')) { scoreB++; B_reasons.push(trigger); }
  if (rr !== null && rr >= 2) { scoreB++; B_reasons.push(`R:R ${rr.toFixed(1)}`); }
  if (riskPass) { scoreB++; B_reasons.push(`風險距離 ${(riskDistPct * 100).toFixed(1)}%`); }
  
  if (scoreB >= 2) return { grade: 'B', reasons: B_reasons.slice(0, 3) };
  
  return { grade: 'C', reasons: reasons.length > 0 ? reasons : ['未達 B 級條件'] };
}


// Final Builder
function TP_buildTradePlan(inputs) {
  const capital = parseFloat(document.getElementById('tpInputCapital').value) || 100000;
  const riskPct = parseFloat(document.getElementById('tpInputRiskPct').value) || 1;
  
  // 1. Regime
  const regimeRes = TP_decideRegime(inputs);
  
  // 2. Trigger
  const triggerRes = TP_calcTriggers(inputs);
  inputs.triggerRes = triggerRes; 
  
  // 3. Stops
  const structStopRes = calcStructureStop(inputs, regimeRes.regime);
  const trendStopRes = {
    price: inputs.lastMA * (regimeRes.regime === 'SHORT' ? 1.05 : 0.95),
    source: `${inputs.maType}${state.maLen} x ${regimeRes.regime === 'SHORT' ? '1.05' : '0.95'}`
  };
  
  // Recalc riskDistPct with the actual structure stop for grading
  let riskDistPct = 1.0;
  if (structStopRes.price && inputs.lastClose > 0) {
      riskDistPct = Math.abs(inputs.lastClose - structStopRes.price) / inputs.lastClose;
      if (riskDistPct < 0) riskDistPct = 1.0; // Stop is not lower than entry price
  }
  
  // 4. Position Sizing
  const posSizeRes = TP_calcPositionSizing(inputs, capital, riskPct);
  
  // 5. R:R
  const rrRes = TP_calcRR(inputs, posSizeRes.entryPrice, structStopRes.price);
  
  const plan = {
    regimeRes,
    triggerRes,
    structStopRes,
    trendStopRes,
    riskDistPct,
    posSizeRes,
    rrRes,
    capital,
    riskPct
  };
  
  // 6. Grade (Needs all prior results)
  const gradeRes = TP_calcGrade(inputs, plan);
  plan.gradeRes = gradeRes;
  
  return plan;
}


// Final Renderer
function TP_renderTradePlan(plan) {
  const contentEl = document.getElementById('tp_content_summary');
  const gradePillEl = document.getElementById('tp_grade_pill');
  const gradeDetailsEl = document.getElementById('tp_grade_details');
  const doDontEl = document.getElementById('tp_do_dont');
  const lang = state.lang || 'zh';
  
  if (!contentEl) return;
  
  const { regimeRes, triggerRes, structStopRes, trendStopRes, riskDistPct, posSizeRes, rrRes, capital, riskPct, gradeRes } = plan;
  
  const f = (val, symbol) => formatPrice(val, symbol);
  const fPct = (val) => (val * 100).toFixed(1) + "%";
  
  // --- Setup Grade (8) ---
  if (gradePillEl) {
    const grade = gradeRes.grade;
    gradePillEl.className = `status-pill status-${grade === 'A' ? 'pass' : (grade === 'B' ? 'warn' : 'fail')}`;
    gradePillEl.innerText = grade;
  }
  
  if (gradeDetailsEl) {
    gradeDetailsEl.style.display = 'block';
    gradeDetailsEl.innerHTML = `
      <strong style="color: ${gradeRes.grade === 'A' ? 'var(--up-color)' : (gradeRes.grade === 'B' ? 'var(--warn-color)' : 'var(--down-color)')}">${lang==='zh'?'評級 (Grade)':'Setup Grade'}: ${gradeRes.grade}</strong>
      <ul class="dragon-reason-list" style="margin-top: 4px; padding-left: 20px;">
        ${gradeRes.reasons.map(r => `<li style="list-style-type: none; position: relative; padding-left: 14px;"><span style="color:var(--accent-color); position: absolute; left: 0;">•</span>${r}</li>`).join('')}
      </ul>
    `;
  }

  // --- Summary (1, 2, 3, 4, 5) ---
  const mkSummaryItem = (lblZh, lblEn, val, color) => `
    <div style="display:flex; justify-content:space-between; margin-bottom:6px; font-size:13px; padding:0 4px;">
      <span style="color:#8d9096;">${lang==='zh'?lblZh:lblEn}</span>
      <span style="color:${color}; font-weight:600;">${val}</span>
    </div>`;

  let html = '';
  
  // 1. Regime
  const regimeColor = regimeRes.regime === 'LONG' ? 'var(--up-color)' : (regimeRes.regime === 'SHORT' ? 'var(--down-color)' : '#fff');
  html += mkSummaryItem('環境 (Regime)', 'Regime', regimeRes.regime, regimeColor);

  // 2. Trigger
  const triggerColor = plan.triggerRes.trigger.includes('Confirmed') || plan.triggerRes.trigger.includes('Accepted') ? 'var(--up-color)' : 'var(--warn-color)';
  html += mkSummaryItem('觸發 (Trigger)', 'Trigger', triggerRes.trigger, triggerColor);
  
  // 3. Stops
  const sStopVal = structStopRes.price ? f(structStopRes.price, state.symbol) : (lang==='zh'?'不合理/無效':'Invalid/None');
  const tStopVal = f(trendStopRes.price, state.symbol);
  
  let structStopHintZh = structStopRes.source + ' (進場失效)';
  let structStopHintEn = structStopRes.source + ' (trade invalidation)';
  
  let trendStopHintZh = trendStopRes.source + ' (持有防守)';
  let trendStopHintEn = trendStopRes.source + ' (trend defense)';

  html += '<div style="margin-top: 10px; padding-top: 10px; border-top: 1px dashed #333;"></div>'; // Separator

  html += mkSummaryItem(
    lang==='zh'?'結構停損 (Structure Stop)':'Structure Stop', 
    'Structure Stop', 
    `${sStopVal} <span style="font-size:11px; color:#555;">(${lang==='zh'?structStopHintZh:structStopHintEn})</span>`, 
    structStopRes.price ? 'var(--down-color)' : 'var(--warn-color)'
  );
  html += mkSummaryItem(
    lang==='zh'?'趨勢停損 (Trend Stop)':'Trend Stop', 
    'Trend Stop', 
    `${tStopVal} <span style="font-size:11px; color:#555;">(${lang==='zh'?trendStopHintZh:trendStopHintEn})</span>`, 
    '#fff'
  );

  // 4. Position Sizing
  const riskTxt = posSizeRes.stopValid ? `${fPct(riskPct)} / $${posSizeRes.riskDollar.toFixed(0)}` : (lang==='zh'?'風險無效':'Risk Invalid');
  const entryTxt = posSizeRes.entrySourceZh;
  const entryPriceVal = f(posSizeRes.entryPrice, state.symbol);
  const sharesTxt = posSizeRes.stopValid ? `${posSizeRes.shares} 股 / $${posSizeRes.positionDollar.toFixed(0)}` : (lang==='zh'?'不交易':'No Trade');
  const sharesColor = posSizeRes.shares > 0 ? 'var(--accent-color)' : 'var(--warn-color)';
  
  html += '<div style="margin-top: 10px; padding-top: 10px; border-top: 1px dashed #333;"></div>'; // Separator
  html += mkSummaryItem('預計進場價', 'Est. Entry', entryPriceVal, '#fff');
  html += mkSummaryItem('單股風險 $', 'Per-share Risk', posSizeRes.perShareRisk > 0 ? f(posSizeRes.perShareRisk, state.symbol) : '-', 'var(--down-color)');
  html += mkSummaryItem('單筆風險 (Risk $)', 'Risk Amt', riskTxt, posSizeRes.stopValid ? 'var(--down-color)' : 'var(--warn-color)');
  html += mkSummaryItem('建議部位 (Shares)', 'Shares', sharesTxt, sharesColor);
  
  // 5. R:R
  const rrTxt = rrRes.rr ? rrRes.rr.toFixed(1) : (lang==='zh'?'無目標 (N/A)':'No Target (N/A)');
  const rrColor = rrRes.rr >= 3 ? 'var(--up-color)' : (rrRes.rr >= 2 ? 'var(--warn-color)' : 'var(--down-color)');
  const targetVal = rrRes.targetPrice ? f(rrRes.targetPrice, state.symbol) : (lang==='zh'?'N/A':'N/A');
  html += '<div style="margin-top: 10px; padding-top: 10px; border-top: 1px dashed #333;"></div>'; // Separator
  html += mkSummaryItem('目標價 (Target)', 'Target Price', `${targetVal} <span style="font-size:11px; color:#555;">(${lang==='zh'?rrRes.targetSourceZh:rrRes.targetSourceEn})</span>`, '#fff');
  html += mkSummaryItem('R:R', 'R:R Ratio', rrTxt, rrColor);

  contentEl.innerHTML = html;
  
  // --- Do / Don't (9) ---
  const doList = [];
  const dontList = [];
  
  const isConfirmed = triggerRes.trigger.includes('Confirmed');
  const isPullbackAccepted = triggerRes.trigger.includes('Accepted');

  if (lang === 'zh') {
    if (!isConfirmed && !isPullbackAccepted) {
      doList.push("等待突破站穩或回測承接 (Trigger 未確認)");
    } else if (isConfirmed || isPullbackAccepted) {
      doList.push("突破確認先試單、回測承接再加碼");
    }
    doList.push(`嚴守結構停損 (${sStopVal}) 退出 (進場失效)`);
    
    dontList.push("在壓力下追價 (Chase)");
    dontList.push("RS < 0 追反彈");
    dontList.push("沒有停損就進場 (Structure Stop 為必要)");
  } else {
    if (!isConfirmed && !isPullbackAccepted) {
      doList.push("Wait for confirmed breakout/pullback setup (Trigger Unconfirmed)");
    } else if (isConfirmed || isPullbackAccepted) {
      doList.push("Use starter size on confirmation, add on accepted pullback");
    }
    doList.push(`Strictly exit on Structure Stop (${sStopVal}) break (Trade Invalidation)`);
    
    dontList.push("Chase under resistance");
    dontList.push("Long weak RS stocks (RS < 0)");
    dontList.push("Enter without a defined Structure Stop");
  }

  const mkList = (title, items, color) => `
    <div style="margin-bottom:8px;">
      <div style="font-size:12px; color:${color}; font-weight:bold; margin-bottom:2px;">${title}</div>
      <ul class="dragon-reason-list" style="margin:0; padding-left:16px; font-size:12px; color:#ccc;">
        ${items.map(i => `<li style="list-style-type: none; position: relative; padding-left: 14px;"><span style="color:${color}; position: absolute; left: 0;">•</span>${i}</li>`).join('')}
      </ul>
    </div>
  `;

  doDontEl.innerHTML = `
    ${mkList(lang==='zh'?'操盤鐵律 (Do - 執行)':'Trade Rules (Do)', doList, 'var(--up-color)')}
    ${mkList(lang==='zh'?'操盤鐵律 (Don\'t - 禁止)':'Trade Rules (Don\'t)', dontList, 'var(--down-color)')}
  `;
  
  // --- Disclaimer (2.C) ---
  const disclaimerEl = document.getElementById('tp_disclaimer');
  if (disclaimerEl) {
    disclaimerEl.innerText = lang==='zh'?'本工具為技術分析彙整與量化輔助，非任何個人/課程之官方內容':"This is a quantitative TA helper. Not affiliated with any individual/course.";
  }
}

// --- Initialization & Callbacks (10) ---

// Extend initUI for new inputs and localStorage
function TP_initUI() {
  // Load localStorage
  const storedCapital = localStorage.getItem('tpCapital');
  const storedRiskPct = localStorage.getItem('tpRiskPct');
  
  if (storedCapital) state.riskCapital = parseFloat(storedCapital);
  if (storedRiskPct) state.riskPct = parseFloat(storedRiskPct);
  
  const capInput = document.getElementById('tpInputCapital');
  const pctInput = document.getElementById('tpInputRiskPct');
  
  if (capInput) {
    capInput.value = state.riskCapital;
    capInput.onchange = (e) => { 
      state.riskCapital = parseFloat(e.target.value) || 100000;
      localStorage.setItem('tpCapital', state.riskCapital);
      // Recalculate everything
      const tpContext = INTEG_collectInputs();
      if (tpContext) {
        const checklistEl = document.getElementById('checklistItems');
        const passCount = checklistEl ? checklistEl.querySelectorAll('.status-pass').length : 0;
        const totalCount = checklistEl ? checklistEl.querySelectorAll('.check-item-row').length : 1;
        tpContext.checklistPassRatio = passCount / totalCount;
        const tpPlan = TP_buildTradePlan(tpContext);
        TP_renderTradePlan(tpPlan);
      }
    };
  }
  
  if (pctInput) {
    pctInput.value = state.riskPct;
    pctInput.onchange = (e) => { 
      state.riskPct = parseFloat(e.target.value) || 1; 
      localStorage.setItem('tpRiskPct', state.riskPct);
      // Recalculate everything
      const tpContext = INTEG_collectInputs();
      if (tpContext) {
        const checklistEl = document.getElementById('checklistItems');
        const passCount = checklistEl ? checklistEl.querySelectorAll('.status-pass').length : 0;
        const totalCount = checklistEl ? checklistEl.querySelectorAll('.check-item-row').length : 1;
        tpContext.checklistPassRatio = passCount / totalCount;
        const tpPlan = TP_buildTradePlan(tpContext);
        TP_renderTradePlan(tpPlan);
      }
    };
  }
}
// END: TRADE_PLAN_CARD_V2


// START: WEIN Functions
let WEIN_dailyData = []; // Store raw daily to re-aggregate

function WEIN_handleFileUpload(input) {
  const file = input.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (e) => {
    const text = e.target.result;
    WEIN_dailyData = WEIN_parseCSV(text);
    if (!WEIN_dailyData || WEIN_dailyData.length === 0) {
      // NOTE: Using custom modal/toast instead of alert() as per instruction, but keeping simple alert() here as it's an auxiliary feature not core UI.
      alert("CSV 解析失敗，請確認格式 (Date,Open,High,Low,Close,Volume)"); 
      return;
    }
    
    // Explicitly set state to show CSV chart immediately
    const weekly = WEIN_dailyToWeekly(WEIN_dailyData);
    state.weinMode = true;
    state.symbol = "CSV_IMPORT";
    state.interval = "1wk";
    state.dataCache.stock = weekly;
    state.dataCache.benchmark = []; // Clear benchmark for CSV
    
    // Call recalc to update UI and calc stage
    WEIN_recalcFromWeekly();
  };
  reader.readAsText(file);
}

function WEIN_parseCSV(text) {
  const lines = text.trim().split('\n');
  if (lines.length < 2) return [];
  const headers = lines[0].split(',').map(s => s.trim().toLowerCase());
  
  // Find indices
  const idxDate = headers.indexOf('date');
  const idxOpen = headers.indexOf('open');
  const idxHigh = headers.indexOf('high');
  const idxLow = headers.indexOf('low');
  const idxClose = headers.indexOf('close');
  const idxVol = headers.indexOf('volume');
  
  if (idxDate < 0 || idxClose < 0) return []; // Minimal requirement

  const data = [];
  for (let i = 1; i < lines.length; i++) {
    const cols = lines[i].split(',').map(s => s.trim());
    if (cols.length < headers.length) continue;
    
    // Parse Date
    const dStr = cols[idxDate];
    let ts = new Date(dStr).getTime() / 1000;
    if (isNaN(ts)) continue; // Try generic parse
    
    // Simple values
    const o = parseFloat(cols[idxOpen]);
    const h = parseFloat(cols[idxHigh]);
    const l = parseFloat(cols[idxLow]);
    const c = parseFloat(cols[idxClose]);
    const v = parseFloat(cols[idxVol]) || 0;
    
    if (!isNaN(c)) {
      data.push({ time: ts, open: o, high: h, low: l, close: c, volume: v });
    }
  }
  return data.sort((a,b) => a.time - b.time);
}

function WEIN_dailyToWeekly(daily) {
  if (!daily.length) return [];
  
  const weekly = [];
  let currentWeek = [];
  
  function getWeekKey(ts) {
    const d = new Date(ts * 1000);
    d.setHours(0,0,0,0);
    d.setDate(d.getDate() + 4 - (d.getDay()||7)); // Adjust to Thursday
    const year = d.getFullYear();
    const weekNo = Math.ceil(( ( (d - new Date(year, 0, 1)) / 86400000) + 1) / 7);
    return year + '-' + weekNo;
  }

  let currentKey = null;
  let wOpen=0, wHigh=-Infinity, wLow=Infinity, wClose=0, wVol=0;
  let wTime = 0;

  for (let i=0; i<daily.length; i++) {
    const bar = daily[i];
    const key = getWeekKey(bar.time);
    
    if (key !== currentKey) {
      if (currentKey !== null) {
        weekly.push({ time: wTime, open: wOpen, high: wHigh, low: wLow, close: wClose, volume: wVol });
      }
      currentKey = key;
      wOpen = bar.open;
      wHigh = bar.high;
      wLow = bar.low;
      wClose = bar.close;
      wVol = bar.volume;
      wTime = bar.time; // Update time to current
    } else {
      // Accumulate
      wHigh = Math.max(wHigh, bar.high);
      wLow = Math.min(wLow, bar.low);
      wClose = bar.close; // Latest close
      wVol += bar.volume;
      wTime = bar.time; // Use latest date as bar date
    }
  }
  // Push last
  if (currentKey !== null) {
    weekly.push({ time: wTime, open: wOpen, high: wHigh, low: wLow, close: wClose, volume: wVol });
  }
  
  return weekly;
}

function WEIN_computeStage(weeklyData, params) {
  // 1. Calc SMA
  const sma = calcMA(weeklyData, params.maLen, 'SMA');
  const smaMap = new Map();
  sma.forEach(m => smaMap.set(m.time, m.value));
  
  // 2. Determine Stage for the LAST bar (current state)
  
  const lastBar = weeklyData[weeklyData.length-1];
  if (!lastBar) return 1;
  
  // Need slope: ma(now) - ma(now - 3weeks)
  const idx = weeklyData.length - 1;
  const idxPrev = idx - params.slopeLookback;
  
  const maNow = smaMap.get(lastBar.time);
  const prevBar = weeklyData[idxPrev];
  const maPrev = prevBar ? smaMap.get(prevBar.time) : null;
  
  if (!maNow || !maPrev) return 3; // Not enough data
  
  const slope = maNow - maPrev;
  const close = lastBar.close;
  
  // Logic D
  // Stage 2: Close >= ma*1.03 && slope > 0
  if (close >= maNow * params.thresh2 && slope > 0) return 2;
  
  // Stage 4: Close <= ma*0.97 && slope < 0
  if (close <= maNow * params.thresh4 && slope < 0) return 4;
  
  // Stage 1: abs(slope) <= ma*0.005 && Close in 0.95~1.05
  if (Math.abs(slope) <= maNow * params.slopeThresh && 
      close >= maNow * 0.95 && close <= maNow * 1.05) return 1;
      
  // Else
  return 3;
}

// Helper: Get source bars
function WEIN_getSourceBars() {
  // Prioritize WEIN_dailyData if it exists (meaning CSV uploaded)
  if (WEIN_dailyData && WEIN_dailyData.length > 0) return WEIN_dailyData;
  // Fallback to current state stock data (for online mode apply)
  if (state.dataCache.stock && state.dataCache.stock.length > 0) return state.dataCache.stock;
  return [];
}

// Helper: Check if current TF is weekly
function WEIN_isWeeklyTF() {
  return state.interval === '1wk' || state.interval === '1w' || state.interval === 'wk';
}

function WEIN_recalcFromWeekly() {
  // 1. Get Source
  const src = WEIN_getSourceBars();
  
  if (!src || src.length === 0) {
      setStatus("請先按『分析』載入資料，或上傳 CSV", true); 
      return;
  }

  // 2. Determine Weekly Data
  let weekly;
  if (src === WEIN_dailyData) {
      weekly = WEIN_dailyToWeekly(src);
  } else {
      weekly = WEIN_isWeeklyTF() ? src : WEIN_dailyToWeekly(src);
  }
  
  // START: INTEGRATED_UPGRADE_V2 Task 2: Explicit Calibration
  // 3. Read Params with explicit limits
  let maLenIn = parseInt(document.getElementById('weinMA').value);
  let slpLbIn = parseInt(document.getElementById('weinSlopeLB').value);
  let th2In = parseFloat(document.getElementById('weinThresh2').value);
  let th4In = parseFloat(document.getElementById('weinThresh4').value);
  let slpThIn = parseFloat(document.getElementById('weinSlopeThresh').value);

  // Sanitize
  const p = {
    maLen: isNaN(maLenIn) ? 30 : Math.max(5, Math.min(200, maLenIn)),
    slopeLookback: isNaN(slpLbIn) ? 3 : Math.max(1, Math.min(26, slpLbIn)), // Fix 0 -> 1
    thresh2: isNaN(th2In) ? 1.03 : Math.max(0.5, Math.min(2.0, th2In)),
    thresh4: isNaN(th4In) ? 0.97 : Math.max(0.5, Math.min(2.0, th4In)),
    slopeThresh: isNaN(slpThIn) ? 0.005 : Math.max(0.0001, Math.min(0.2, slpThIn))
  };
  
  // 4. Compute Stage & Feedback
  const prevStage = state.weinStage;
  state.weinMode = true;
  state.weinStage = WEIN_computeStage(weekly, p);
  
  // Feedback Stats
  const lastBar = weekly[weekly.length-1];
  const sma = calcMA(weekly, p.maLen, 'SMA');
  const lastMA = sma.length > 0 ? sma[sma.length-1].value : 0;
  const ratio = lastMA ? (lastBar.close / lastMA) : 0;
  
  // Calc Slope
  let slope = 0;
  const smaMap = new Map(); sma.forEach(m => smaMap.set(m.time, m.value));
  const idxPrev = weekly.length - 1 - p.slopeLookback;
  if(idxPrev >= 0) {
      const prevMA = smaMap.get(weekly[idxPrev].time);
      if(prevMA) slope = lastMA - prevMA;
  }
  
  // Hit Reason logic
  let reason = "Stage 3 (Default)";
  if (lastBar.close >= lastMA * p.thresh2 && slope > 0) reason = `Close >= MA*${p.thresh2.toFixed(3)} & Slope>0 → Stage 2`;
  else if (lastBar.close <= lastMA * p.thresh4 && slope < 0) reason = `Close <= MA*${p.thresh4.toFixed(3)} & Slope<0 → Stage 4`;
  else if (Math.abs(slope) <= lastMA * p.slopeThresh && lastBar.close >= lastMA * 0.95 && lastBar.close <= lastMA * 1.05) reason = "Flat Slope & Close near MA → Stage 1";

  // Update Feedback UI
  const fbEl = document.getElementById('weinFeedback');
  if(fbEl) {
      fbEl.style.display = 'block';
      const lang = state.lang || 'zh';
      
      const paramsTxt = `MA=${p.maLen}, SlopeLB=${p.slopeLookback}, Th2=${p.thresh2.toFixed(3)}, Th4=${p.thresh4.toFixed(3)}`;
      const dataTxt = `Close=${lastBar.close.toFixed(2)}, MA=${lastMA.toFixed(2)}, Ratio=${ratio.toFixed(3)}, Slope=${slope.toFixed(3)}`;
      const stageChg = prevStage === state.weinStage ? `Stage ${state.weinStage} (未變)` : `Stage ${prevStage} -> ${state.weinStage}`;
      const tip = lang === 'zh' ? "快速驗證：把 Stage 2 Threshold 設 1.20 再 Apply，若 Close/MA < 1.20，Stage 應不再是 2。" : "Quick Check: Set Thresh2 to 1.20. If Ratio < 1.20, Stage should drop.";
      
      // Task A: Input Correction Warning
      let warning = "";
      if (slpLbIn === 0) {
          warning = lang === 'zh' ? 
            "<div style='color:var(--warn-color); margin-bottom:4px;'>⚠️ 輸入值已校正：Slope Lookback 0 → 1</div>" : 
            "<div style='color:var(--warn-color); margin-bottom:4px;'>⚠️ Input corrected: Slope Lookback 0 → 1</div>";
      }

      fbEl.innerHTML = `
        ${warning}
        <div><strong>Params:</strong> ${paramsTxt}</div>
        <div><strong>Data:</strong> ${dataTxt}</div>
        <div><strong>Result:</strong> ${stageChg}</div>
        <div><strong>Reason:</strong> ${reason}</div>
        <div style="margin-top:4px; font-style:italic; opacity:0.8; border-top:1px solid #444; padding-top:2px;">${tip}</div>
      `;
  }
  // END: INTEGRATED_UPGRADE_V2 Task 2

  // 5. Update UI (recalcIndicators triggers updateAnalysisPanel which uses weinStage)
  recalcIndicators();

  // 6. Status Feedback
  let msg = "已套用韋恩斯坦參數 (Weinstein Params Applied)";
  if (!WEIN_isWeeklyTF() && src !== WEIN_dailyData) {
      msg += " - 注意：韋恩斯坦建議以週線解讀";
  }
  setStatus(msg);
}

function WEIN_applyWeeklyToState(weeklyData, params) {
  // Retained but not used in Apply flow to avoid overwriting online data
  state.weinMode = true;
  state.symbol = "CSV_IMPORT";
  state.interval = "1wk";
  state.maLen = params.maLen;
  state.maType = 'SMA'; 
  state.dataCache.stock = weeklyData;
  state.dataCache.benchmark = [];
  recalcIndicators();
}
// END: WEIN Functions
</script>
</body>
</html>

